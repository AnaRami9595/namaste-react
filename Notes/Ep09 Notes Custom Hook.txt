Single Responsability Principle ğŸª

The Single Responsibility Principle (SRP) is one of 
the SOLID principles of object-oriented design.
SRP states that a class or module should have only one
reason to change, which means that it should have only
one responsibility or job.

Inside our app we have different componentsğŸ§© which ideally
perform a single task

Modularity means that you break down your code in 
different chunksğŸª or modules. That makes them 
more resusable, maintainable and testable.

ğŸ’¡Rule of thumb: keep your components as light as 
possible

One tool that can help us achieve more modularity are
Custom HooksğŸª
a custom hook is a JavaScript function that allows you 
to encapsulate and reuse logic or side-effects across 
different components. Custom hooks are a powerful way 
to share stateful logic without relying on class
components or duplicating code. 

In this lesson we will make a Custom HookğŸª

ğŸ”´------ Making a Custom HookğŸª-----

Our RestaurantMenu.jsğŸŸ¨ ComponentğŸ§© has 2 jobs:
fetching the data from the API and displaying it to 
the UIğŸ–Œï¸. 

However, this doesn't obey the SRPğŸª very well, also
how cool would that be if our RestaurantMenu.jsğŸŸ¨
component would just be responsible of taking
 ANY kind of restaurant data and displaying it without
 worrying about fetchingğŸ• it or manage its own state???

 We can achieve that with a custom HOOKğŸª

ğŸ”¸Let's create our own custom HookğŸª that will fetch the 
Data and give it to our RestaurantMenu.jsğŸŸ¨ component

    -Remember that a HookğŸª is an utility function, that we will 
    probably reuse, so in this case it will be appropiate to save
    it inside our utilsğŸ“ folder.
    We will name it using the convention of applying the prefix
    "use", following the recommended convention. 

    Inside our useRestaurantMenu.jsğŸŸ¨ we will write:

                ğŸ–¥ï¸
                import { useEffect, useState } from "react";
                import { MENU_API } from "./constants";

                const useRestaurantMenu = (resId) => {
                
                    const [resInfo, setResInfo] = useState(null)

                     //fetchdatağŸ•:
                    useEffect(() => {
                        fetchData()
                    }, [])

                    const fetchData = async () => {
                        const data = await fetch(MENU_API + resId);
                        const json = await data.json()
                        setResInfo(json)
                    };

                    return (resInfo);
                }

                export default useRestaurantMenu;
                ğŸ–¥ï¸

                //As you can see, inside this HookğŸªwe fetch
                //the required data to create the restaurant menu
                //and store it inside a useStateâ˜ï¸ Variable to set
                //it's value to our json data. We also exportâœˆï¸ it
                //so we can use it inside of our RestaurantMenu 
                //ComponentğŸ§©


ğŸ”¸Inside our RestaurantMenu ComponentğŸ§© we will import our 
useRestaurantMenu HookğŸªin order to display the menu items to each
of the restaurants

                ğŸ–¥ï¸import Shimmer from "./Shimmer";
                import { useParams 
                } from "react-router-dom";
                import useRestaurantMenu from "utils/useRestaurantMenu";

                const RestaurantMenu = () => {

                    const { resId } = useParams()

                    const resInfo = useRestaurantMenu(resId)

                    if (resInfo === null) return <Shimmer />

                    const { name, cuisines, cost } = resInfo?.info;

                    const { foodOptions } = resInfo


                    return (
                        <div className="menu">
                            <h1>{name}</h1>
                            <h3>{cuisines.join(", ")} - {cost} </h3>
                            <h2>Menu</h2>
                            <ul>
                                {foodOptions.map((item) => <li key={
                                    item.card.info.id}>
                                    {item.card.info.name} - â‚¹{
                                        item.card.info.price}</li>)}

                            </ul>
                        </div>)
                }

                export default RestaurantMenu;
                ğŸ–¥ï¸

                //Now this ComponentğŸ§© is only receiving the 
                //resInfo thanks to the useRestaurantMenu HookğŸª
                //and passing the value given by useParams
                //in order to display the menu items depending on
                //the restaurant.

ğŸ”´------ Making a Second Custom HookğŸª-----

In order to tighten our knowledge, let's create another custom hook 
that will show our online/offline status depending if our internet
is working 

        ğŸ’¡Tips for writing a good custom HookğŸª

         â€¢ First thing you should do is FINALIZE
           the contractğŸ“œ. That means specifying 
           what is the input of the hookğŸª and what
           is the Output of the HookğŸª


ğŸ”¸Our custom hookğŸª will be called useOnlineStatusğŸ“¶ that will be 
once again, inside our utils folderğŸ“.

In our contractğŸ“œwe will be not requiring any parameters, that means
that we will not ask to the componentğŸ§© (or the callerâ˜ï¸) for any data. 
However, we will be returning the online status, that will be a boolean 
value, returning a truthy value if the answer is online, and a falsy 
if they don't have internet connection. And then export it


                ğŸ–¥ï¸
                const useOnlineStatus = () => {
                //check if online, 
                //return a boolean

                return useOnlineStatus
                }

                export default useOnlineStatus;

                ğŸ–¥ï¸
                //this is like a sketch of our hookğŸª
                //what's missing is the logic to
                //check if the userğŸ‘¤ is online or not


ğŸ”¸ In order to check if the userğŸ‘¤ is online or not, first we will
create a stateâ˜ï¸ variable called "Online Status" so we can store
the value and change it later

For that we will be using an Event ListenerğŸ‘‚ called online event. 
That the browserğŸŒ has givento us already.

We only want to apply this Event ListenerğŸ‘‚ once, so in order to 
achieve that we will import useEffectğŸ’¥ with an empty Dependencyâ›“ï¸
array so we can apply it only after the first renderğŸ–Œï¸

Inside the useEffectğŸ’¥ we will check the useOnlineStatusğŸ“¶, 


            ğŸ–¥ï¸import { useEffect, useState } from "react";

            const useOnlineStatus = () => {

                //save our online status inside a state variable
                //with default value as "true"
                //so we can change it's state and return it laterğŸ‘‡

                const [onlineStatus, setOnlineStatus] = useState(true)

                useEffect(() => {
                    //After our first render, if we are offline, we'll
                    //change it's status to "false"ğŸ‘‡
                    window.addEventListener("offline", () => {
                        setOnlineStatus(false)
                    })

                    //After our first render, if we are online, we'll
                    //change it's status to "true"ğŸ‘‡
                    window.addEventListener("online", () => {
                        setOnlineStatus(true)
                    })

                }, []);

                //We return our stateâ˜ï¸ variable
                return onlineStatus;
            }

            export default useOnlineStatus;


ğŸ”¸ Now let's put our hookğŸª to use and display a message to the 
userğŸ‘¤ inside our Body.jsğŸŸ¨ componentğŸ§©. First we importe it. 
Before the return keyword we'll add a conditional statement, if our
online status is false, then we will return a message to the user 
in the UIğŸ–Œï¸

            ğŸ–¥ï¸//Inside Body.jsğŸŸ¨:
            import useOnlineStatus from "../../utils/useOnlineStatus"
            ...
            const Body = () => {
                ...
                //save the returning value from the hookğŸª
                //inside a variable: ğŸ‘‡
                const onlineStatus = useOnlineStatus()

                //checking the value of our variableğŸ‘‡
                if (!onlineStatus) {
                    return (
                        <h1>Looks like you're offline ğŸ˜¬</h1>
                    )
                }

                //rest of the previous codeğŸ”½
                return !listOfRestaurants.length ?
                <Shimmer /> : (
                    ...
                )
                        }ğŸ–¥ï¸
                
                //Now when the userğŸ‘¤is offline, our message
                //will be displayed!!


ğŸ”¸In order to show the reusability of custom HooksğŸª, let's use the
same logic of our useOnlineStatusğŸ“¶ in order to add an "online"
symbol in our navbar to check or network status at all times.

Inside our Header.jsğŸŸ¨ componentğŸ§© we'll create another <li>
that will display our online status 

            ğŸ–¥ï¸//Inside Header.jsğŸŸ¨:
            ...
            import useOnlineStatus from "../../utils/useOnlineStatus";
            ...
            //save the returning value from the hookğŸª
            //inside a variable: ğŸ‘‡
            const onlineStatus = useOnlineStatus()

            const Header = () => {
                return (
                    ...
                    <div className="nav-items">
                        <ul>
                            <li>

                            {//checking the val of our variableğŸ‘‡

                            onlineStatus ? "ğŸŸ¢online" : "ğŸ”´offline"
                            }
                            </li>
                    ...
                    </div>
                    ...
                )
            }


ğŸ”´------Optimizing our app MORE-----

        ğŸ’¡TANGENT!! Revision about BundlingğŸ“š
        The problem with developing a big scale app is CompressingğŸ—ƒï¸ all the files
        into one. This is thankfully made with a BundlerğŸ“š, in this case, as we've 
        seen, we are using ParcelğŸ“¦.

        Since we're using developer node, we have a main jsğŸŸ¨ file inside our distğŸ“‚
        but when it's a ProductionğŸ‘·ğŸ»â€â™€ï¸ build, then the code looks all compressed and 
        minified. BundlingğŸ“š all the files in a single one.

        ğŸ¤”What is the problem with this?
        Is it wrong to have a single JavascriptğŸŸ¨ File for everything?
        Not really but as your app becomes more complex and detailed, The
        size of that file increases and makes it heavy, therefore slow and
        it would take a long time to load

        So there's a time when having a single jsğŸŸ¨ file for the whole app becomes
        contraproductive.

        In this case we can use a process called Chunnking or 
        Code Splitting

ğŸ”´------Optimizing our app MORE-----

What is chunkingğŸª or code Splitting?

Code Splitting, also known as chunkingğŸª, is a technique used in web development
to optimize the loading performance of web applications. It involves
breaking down a large jsğŸŸ¨ BundleğŸ“š (the compiled and minifiedd JavascriptğŸŸ¨
code that contains all the application's code) into smaller, more 
manageable pieces of code.

You have too do bundling in a dynamic way

Is like Uber that has cabs, food delivery and also grocery delivery, 
inside the app you can find a link for the other cab app ComponentğŸ§©
and supermarket componentğŸ§©.

Let's make a simulation of this inside our app, to learn more

we'll call it Grocery.jsğŸŸ¨
We'll create a new path for our componentğŸ§© and assign a 
link for it inside our Header.jsğŸŸ¨ componentğŸ§©

How would we configure it so Grocey.js and all its components
come from a different BundleğŸ“š??

Using lazy() loadingğŸ˜ª


ğŸ”´------Lazy loadingğŸ˜ª-----

Also known as 

ChunkingğŸª
Code Splitting
Dynamic BundlingğŸ“š
Dynamic import
LazyğŸ˜ª loading
On demand Loading


This works like this, when our main componentğŸ§©
loads, it will be not loading the actual code from
our GroceryğŸ›ï¸ BundleğŸ“š.

ONLY when I go to my GroceryğŸ›ï¸ component, the code
will actually work. That is known as Lazy loadingğŸ˜ª
or On-demand Loading.

How would we do that. For starters, we will NOT 
import our code like this:

            ğŸ–¥ï¸//âŒ
            import Grocery from "./components/Grocery";

ğŸ”¹Instead, we will use the ğŸ˜ªlazy() method that is given to us 
by react. First we will import the LazyğŸ˜ª method it from Reactâš›ï¸ 

            ğŸ–¥ï¸//âœ…
            import React, {lazy} from "react";

            //And then, we import our componentğŸ§©.
            //Lazy()ğŸ˜ª takes a callback function, 
            //in this case it will be an âœˆï¸import()
            //method that takes the path of the 
            //componentsğŸ§©

            ğŸ–¥ï¸//
            const Grocery = lazy(() => import(
                "./components/Grocery"))


ğŸ”¹And then we'll use it normally in our createBrowserRouter()
as a path.

            ğŸ–¥ï¸//
            const appRouter = createBrowserRouter([
            {
            path: "/",
            element: <AppLayout />,
            children: [
                ...
                {
                    path: "/groceries",
                    element: <Grocery />
                },
                ....
            ]}
            ...
                ])


ğŸ”¹Those are 2 line of code that are very powerful behind the scenes.

Now on our main page when displayed, does not load our Grocery.js
code until we visit it. and inside our distğŸ“‚ folder, we have a file
with the code for GroceryğŸ›ï¸ that is not in our components.

Also, in the console of the browserğŸŒ, it shows as a different jsğŸŸ¨
file. 

However, since takes a little to load, our html does not display
and ends up showing our âŒError componentğŸ§©, because Reactâš›ï¸ is 
impatient.

    In order to tell it to Wait, we can use the SuspenseğŸ‘» componentğŸ§©
    that is already given to us, like Reactâš›ï¸. First we import it,
    just like we did with the LazyğŸ˜ª method: 

            ğŸ–¥ï¸
            import React, { lazy, Suspense } from "react";

    Then we surround our GroceryğŸ›ï¸ componentğŸ§© Inside our RouterğŸ›£ï¸
    And as a fallback, we display for the user some JSX to indicate
    to the userğŸ‘¤ that the componentğŸ§© is loading.

            ğŸ–¥ï¸
            const appRouter = createBrowserRouter([
                ...,
            {
                path: "/groceries",
            ğŸ‘‰ element: <Suspense fallback={<h1>Loading...</h1>}><Grocery /></Suspense>
            }
            ],
            ...
            )

            