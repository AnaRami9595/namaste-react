
ğŸ”´Difference between Software architecctures

ğŸª¨What is Monolith Architectures?
It is an outdated software architecture that is 
huge, it includes the API, the UI, backend, frontend
all inside a same server.

And even if we wanted a single change it needed to be
compilled and re-render entirely, it was very chuncky


ğŸ”¸Microservice Architectures

In this model, we have different services for 
different jobs, separated. When they are working
toghether they make a big app. They need to 
interact with eachother for the App to work.

ğŸ’¡This is known as Separation of Consoles
And single responsability principles, when every
service has its own jobs.

In this case our project is an UI service

    ğŸ¤”How are this services connected
    All of them run on their un specific ports
    just like ours is runing inside. They make
    a call to external URLSğŸŒ

    http://localhost:1234
    BackEnd can be run in a port 900, 
    etc

ğŸ”´Let's make our own external calls:-----

Using mock data was very useful, but how can we call
actual external data??

They are 2 aproaches to get DATA from Backend

 - First Approach:
    ğŸ”¹Page Loads â¡ï¸ Call to APIğŸ“± â¡ï¸ RENDER UIğŸ–Œï¸
    //As soon as the page loads, our code makes
    a call to an API and renders the UI

 - Second Approachâœ…
    ğŸ”¹Page Loads â¡ï¸ RENDER UIğŸ–Œï¸ â¡ï¸Call to APIğŸ“±â¡ï¸ RENDER App With new DATA

In REACTâš›ï¸ We will always be using the second Approach
It is a better UX. Because we won't have to wait until the
the UI loads copletely to see something in the page.

We are RENDERINGğŸ–Œï¸ twice but it doesn't matter Because
we are rendering very fast.


ğŸ”´------The useEffectğŸ’¥ HOOKğŸª-----

The Syntax:

                ğŸ–¥ï¸useEffect(()=>{}, [])
                //It has 2 arguments: 
                //a CB function and 
                //a Dependencyâ›“ï¸ Array

It will execute when the render cycle is finished, it will call the
CB function

We import it inside our Body.js ComponentğŸ§© like this: 

               ğŸ–¥ï¸ import { useEffect, useState } from "react";

               useEffect(()=>{
                console.log("useEffectğŸ’¥ called")
               }, [])
               //as soon as our Body.js ComponentğŸ§©, it will
               //print in the console


useEffectğŸ’¥ will be useful when we FetchğŸ• the data using the
Second Approachâœ… described earlier.

ğŸ”´------ FetchğŸ• -----

fetchğŸ• is a method provided by the Browser'sğŸŒ Javascript engine
it is a function with super powers that allows us to get external
Data from APIsğŸ“± In this case we are going to FetchğŸ• our data
AFTER our ComponentğŸ§© renders, so we will call the function inside
useEffectğŸ’¥

               ğŸ–¥ï¸useEffect(()=>{
                 fetchData()
                }, [])

And our Fetch data method will look like this. Instead of using
the .then method, we'll use the `async` keyword.

    ğŸ•ºğŸ¾TANGENT!!
        The asyncâŒ› keyword:
        When using FetchğŸ• you may encounter the asyncâŒ›keyword.
        The asyncâŒ› keyword is used in combination with the 
        awaitğŸš keyword to handle asynchronus operations in a
        more readable and sequential manner

            - asyncâŒ›
              When you declare a function as `async` it means
              that the function will always return a PromiseğŸ’
              Inside an asyncâŒ› function you can use awaitğŸš
              to pause the exection of the function, until an 
              asynchronous operation, like a fetchğŸ• request
              is completed. This allows you to write asynchronous
              code in a more synchronous style, easier to read.

            - awaitğŸš
              This keyword it can only be used inside an asyncâŒ›
              funtion. It tells JSğŸŸ¨ to wait for the PromiseğŸ’
              to resolve and return its result before proceding
              with execution of the code. 
              In the context of a fetchğŸ• request, using awaitğŸš
              allows you to wait for the response before handling
              it.

Inside our code we will use the asyncâŒ›keyword like this:

                ğŸ–¥ï¸const fetchData = async () => {
                const data = await fetch("swiggy/api-link.com"
                );
                const json = await data.json();
                console.log(json)
                }

                //However this doesn't work and generates 
                an Error ğŸ˜± because the browserğŸŒ is blocking
                us for getting an external API

                //âŒError "Access to fetch has been blocked by 
                CORS policy"

                Our BrowserğŸŒ chrome is not allowing us to call
                swiggy's API from our server. If there is an
                origin mismatch.

  ğŸ¤”How can we avoid blockers?? In this case we can install
  a chrome extention to avoid CORS, however since the API seems
  to be changing all the time, I will be using for this episode
  a mock json server created by Aditya Shahare 
  (https://github.com/aditya1819) who will help us to get the data
  that we need 


ğŸ”´------ Loadingâ³ screen -----

Instead of a "loading" legend, the best practice is to load a 
Shimmer UI quickly, this
is a fake UI that works as a place holder for
the actual data. 

In this case we will present fake cardss to the 
user. 
Let's make a new ComponentğŸ§© to create this UI.
Under the fetch data function: 


            ğŸ–¥ï¸if (!listOfRestaurants.length) {
            return <Shimmer />
             }
            //We are doing some conditional RENDERINGğŸ–Œï¸
            that means that we will render the cards Under
            the condition that the array doesn't have contents
            to show
            //<Shimmer /> contains a ComponentğŸ§© that is 
            now inside our src folder full of fake gray
            cards that will show on the page when is Loadingâ³
        

      ğŸ’¡CONDITIONAL RENDERINGğŸ–Œï¸ is a jargon in the industry


      You can also use the ternary operator:

            ğŸ–¥ï¸return !listOfRestaurants.length ? <Shimmer /> : (
              <div className="body">
              ...
            )



ğŸ”´------ REVIEW: useStateâ˜ï¸ and Login Feature-----

Now that we have render a page let's ask ourselves, why do we
even need the useStateâ˜ï¸ variable? can we do the same thing 
creating a local JSğŸŸ¨ variable and a function to change it Under
certain conditions ğŸ¤” Let's create a new feature to demostrate
it's usefulness.

  That will be a login/log out button that changes when pressed
  inside header and try to make it change with normal JSğŸŸ¨

              ğŸ–¥ï¸const Header = () => {

              let btnName = "Login"
              return (
              <div className="header">
                ...
                    <button className="btn-login"
                     onClick={() => {
                        btnName = "Log out"//â—€ï¸Trying to change name
                        console.log(btnName)
                    }}
                    >{btnName}â—€ï¸displaying the name
                    </button>
                ...
                </div>
              );
            }

  However this did not work, and instead of changing the UI
  only logged the new name in the console. Why? ğŸ¤”

  This is because the variable got updated, BUT the UI did notâ—
  The button did not have a refresh.
  this is why JSğŸŸ¨ Normal variables don't work in JSX, if you
  want to make your ComponentğŸ§© dinamic, we use stateâ˜ï¸ variables.


  Now let's implement useStateâ˜ï¸ in our button. First, let's try 
  to use it like this just to see what happens:

              ğŸ–¥ï¸const [btnNameReact] = useState("Login")
              //â¬†ï¸at this point, this will work as a normal variable

              ğŸ–¥ï¸const [btnNameReact, setBtnNameReact] = useState("Login")
              //But now, with the second argument, we can change the 
              stateâ˜ï¸ of our button using that function 

              ğŸ–¥ï¸<button className="btn-login" onClick={() => {
                        setBtnNameReact("Log out")ğŸ‘ˆ
                        console.log(btnName)
                    }}
                    >{btnNameReact}
                    </button>

  whenever our state ariable changes, REACTâš›ï¸ refreshes the ComponentğŸ§©
  immediately. 

  ğŸ¤”Is REACTâš›ï¸ refreshing the whole header or only the button?ğŸ¤”
  It will re-render the whole header ComponentğŸ§© â—â—â—â—â—â—

  ğŸ¤”But how can we modify "btnNameReact" if it's declared as a const
  variable?ğŸ¤”
  Whenever it update the value, REACTâš›ï¸ is calling the Header functiona
  once again and now btnNameReact will be a NEW VARIABLE, with a new
  value. The Fiber algorithm is finding the diff with the old UI and the
  new UIğŸ–Œï¸ and finding the only the button needs to change. This is part 
  of the reconciliation ğŸ«‚ process.

  Let's complete the button functionality to change it every time we 
  click on it:

              ğŸ–¥ï¸ <button
                        className="btn-login"
                        onClick={() => {
                            btnNameReact === "Login"â—€ï¸
                                ? setBtnNameReact("Logout")â—€ï¸
                                : setBtnNameReact("Login")â—€ï¸
                            console.log(btnName)
                        }
                        }
                    >
                        {btnNameReact}
                    </button>

ğŸ”´------ Building a search bar ğŸ”-----

  1ï¸âƒ£First let's create a stateâ˜ï¸ variable named "searchText"
  and bind it to our input area on the ğŸ”search bar.

              ğŸ–¥ï¸const [searchText, setsearchText] = useState("");

                <div className="search">
                    <input type="text" placeholder="Type a meal..."
                        value={searchText}â—€ï¸
                        onChange={() => {
                        }}
                    />


  2ï¸âƒ£Now we write some code to the searchğŸ” button to make a change on
  our searchText:

              ğŸ–¥ï¸ <button className="btn"
                        onClick={() => {
                            console.log(searchText)
                        }}
                  >

              //tis is supposed to log the searchText inside the 
              console whenever we click it. However, when we try
              to write something in the input box, we can't!ğŸ˜±
              ğŸ¤”Why???

              The input box will not change unless we change the
              searchTextâ—â—â— we can do that with onSearch


  3ï¸âƒ£Let's add an event handler, onSearch with the e object 

                ğŸ–¥ï¸<input type="text" placeholder="Type a meal..."
                    value={searchText}
                    onChange={(e) => {ğŸ‘ˆ
                        setsearchText(e.target.value)
                    }}
                    />


                //Now it logs our searchText to the consoleâœ…
                //ğŸ’¡Whenever our stateâ˜ï¸ variable updates, the
                //WHOLE ComponentğŸ§© is getting re-renderğŸ–Œï¸â—â—


      ğŸ’¡Whenever a state variable updates, the wole ComponentğŸ§©
      RE-RENDERSğŸ–Œï¸. In this case, is re-rendering everything BUT
      ONLY updating the input box, thanks to the diff processâ—

      INTERVIEW QUESTIONğŸ™ï¸: Why is React fast?
      Because it uses React Fiber, which is an algorithm that 
      that does effective DOMğŸ“„ Manipulation that creates a 
      VIRTUAL DOMğŸ“„ and using Diffingâ˜¯ï¸ then indentifies
      the minimal number of changes to match the new stateâ˜ï¸,
      then it re-rendersğŸ–Œï¸ the whole ComponentğŸ§© but only
      updates the necessary changesâ—â—â—â—â—


  3ï¸âƒ£Let's now apply the filter logic to our search button 


                  ğŸ–¥ï¸<button className="btn"
                  onClick={() => {

                      const filteredRestaurants = listOfRestaurants.filter((res) =>
                          res.info.name.toLowerCase().includes(searchText.toLowerCase())
                      )
                      setListOfRestaurants(filteredRestaurants)
                  }}
              >
                  Search!</button>
    
                //However we have a bugğŸ here: when we filter our 
                //list a first time it works, but when we use it again
                //since our listOfRestaurants has been updated, we 
                //are only searching among the results that were
                // previously filteredğŸ˜±
                
          ğŸ¤”What can we do to reset our listOfRestaurants after we
          use our searchğŸ” bar so it's useful again??



  4ï¸âƒ£Let's create a separate stateâ˜ï¸ variable to host our filtered 
  results so we don't modify our original list


        ğŸ”¸New state variable for the filtered array:

                  ğŸ–¥ï¸const [filteredRestaurants, 
                  setFilteredRestaurants] = useState([])

        ğŸ”¸Set it's value as soon as we fetch the data:
  
                  ğŸ–¥ï¸const fetchData = async () => {
                  const data = await fetch(
                      "http://localhost:3000/hotels");

                  const json = await data.json();

                  setListOfRestaurants(json);
                  setFilteredRestaurants(json);ğŸ‘ˆ
                  };

        ğŸ”¸And now let's apply the logic for the searchğŸ” button
        to  filter the listOfRestaurants array 
        we will set the new value of filteredRestaurants
        to the new "filtered" variable
        This means we can continue using the search button 
        without changing the original list, since we are not
        updating the listOfRestaurants, only the filteredResults

                  ğŸ–¥ï¸ <button className="btn"
                        onClick={() => {
                            const filtered = listOfRestaurants.filter(
                              (res) =>
                                res.info.name.toLowerCase().includes(
                                    searchText.toLowerCase())
                            )
                            setFilteredRestaurants(filtered)
                        }}
                    > Search!</button>

        ğŸ”¸Don't forget to change the cars container so it only
        displays the filteredRestaurants.

                  ğŸ–¥ï¸ <div className="res-container">
                      {filteredRestaurants.map(restaurant => (
                        <RestaurantCard key={restaurant.info.id}
                          resData={restaurant} />
                       ))}
                      </div>

        ğŸ”¸so we essentially created a copy of listOfRestaurants
        in order to modify it without messing with the original
        data!!


        ğŸ’¡â£ï¸Life lesson: CODE SLOW, question yourself every
        line, The people that code faster, take a long time
        to debug. â£ï¸