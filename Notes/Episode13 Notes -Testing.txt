ğŸŸ¢-----Developer TestingğŸ§ª-----â€¢Â·

Here we are going to talk about different ways
to test our application. 

    â€¢ Manual testingğŸ‘ŒğŸ½:
        the practice of checking if your code 
        works and the features are functional.
        this is not very efficient, because if\
        you change the code a little you will 
        need to get back and chec if works.

        Whenever we add a line ri our code, 
        that can introduce bugs in our app
        ANYWHERE. This is specially complicated
        if your'e building a large scale app.

        That's why TestingğŸ§ª is very important

    â€¢  Test CodeâŒ¨ï¸
        Writing test casesğŸ’¼ to prove our app
        works. It will test our application
        automatically, this is what we are 
        going to do today.

            Types of DEVğŸ¤“ caseğŸ’¼ TestingğŸ§ª:

                Â· Unit âºï¸TestingğŸ§ª
                Â· IntegrationğŸš¸ TestingğŸ§ª
                Â· End to EndğŸ”š testing (e2e)

    
ğŸŸ¢-----TYPES of DEVğŸ¤“ TestingğŸ§ª-----â€¢Â·

    â€¢ Unit âºï¸TestingğŸ§ª
      You test your REACTâš›ï¸ components in 
      isolation. If you want to test the 
      header componentğŸ§©, you will try To
      render your header componentğŸ§© in
      isolation to the rest of the app.
      
    â€¢ IntegrationğŸš¸ TestingğŸ§ª
      TestingğŸ§ª the IntegrationğŸš¸ between
      the componentsğŸ§©, all of them are 
      colaborating to make a feature, 
      you will develop a flow of their 
      colaboration, how are they talking to 
      each other  

    â€¢ End to EndğŸ”š testing (e2e)
      It means testing a REACTâš›ï¸ app as 
      soon as the user enters the react
      application until he leaves it,
      checking all the flows. Starts
      on the landing and how the user
      will flow across the app. 
    
    EndğŸ”š to EndğŸ”š testing requires
    different kind of ToolsğŸ”¨, so will be
    only concerned with the first two. 



    ğŸ”¹ğŸ’¡Interview questionğŸ’¡
        TestingğŸ§ª is now considered as part of 
        the developer job. Testing is part of 
        writing code. Make this a habit.

    
ğŸŸ¢-----REACT TESTING LIBRARYğŸ§ªğŸ“š-----â€¢Â·  

        â€¢ is the most common way of testing
        REACTâš›ï¸ code. It is build on top of
        "DOM TESTING LIBRARY" which has a lot
        of other testing LibrariesğŸ“š for other
        frameworks like angular, Vue, etc.

        â—If you are using create-react-app
        this libraryğŸ“š is already integrated,
        but since we are created our app from 
        scratch using parcelğŸ“¦, we'll need 
        to integrate it ourselves.

        â—React Testing Library uses JestğŸƒ
        which is a JSğŸŸ¨ TESTING framework
        JestğŸƒ Is a standard to write test
        casesğŸ’¼.

        ğŸ”¸Process we will complete:
            1. Install REACT TESTING LIBRARYğŸ§ªğŸ“š-
            2. Install JestğŸƒ
            3. Install BabelğŸ¦œ Dependenciesâ›“ï¸
               to work with JestğŸƒ
            4. Configure BabelğŸ¦œ .config file
               to run with JestğŸƒ
            5. Configure ParcelğŸ“¦ config file
               to disable default BabelğŸ¦œ
               transpilation. 
            6. JestğŸƒ configurationğŸ—ï¸
            7. Install jsdomğŸ“‘ libraryğŸ“š
            6. Install @babel/preset-react to
                make JSXğŸ¦  work in test cases
            7. Include @babel/preset-react inside
            my BabelğŸ¦œ configğŸ—ï¸
            8. Install @testing-library/jest-dom
            so we can use functions

    
            Â· Let's install REACT testing Library:

                //ğŸ–¥ï¸inside the terminal:
                > npm install --save-dev @testing-library/react

            Â· Now let's install JestğŸƒ. According with the
            documentation, to use BabelğŸ¦œ we will need 
            to install additional Dependenciesâ›“ï¸:

                //ğŸ–¥ï¸inside the terminal:
                //For instaling JestğŸƒ â¬‡ï¸
                > npm install --save-dev @testing-library/react

                //BabelğŸ¦œ Dependenciesâ›“ï¸â¬‡ï¸
                > npm install --save-dev babel-jest
                 @babel/core @babel/preset-env


            Â· We will also need to configureğŸ—ï¸ BabelğŸ¦œ to 
            target your current version of node by 
            creating a babel.config.js file in the root 
            level of your Project let's create a new file
            named babel.config.js

                //ğŸ–¥ï¸inside babel.config.js
                module.exports = {
                presets: [['@babel/preset-env', {
                    targets: {node: 'current'}}]],
                };

        â—Remember that ParcelğŸ“¦ has already
        BabelğŸ¦œ built in, so these Dependenciesâ›“ï¸
        we just installed will interfere with 
        parcel'sğŸ“¦ so we are trying to configureğŸ—ï¸
        BabelğŸ¦œ according to us.

        It will be a conflict between the 2 
        configurationsğŸ—ï¸ so the one we just did 
        will try to override the existing BabelğŸ¦œ
        configurationsğŸ—ï¸ parcelğŸ“¦ had set for us. 

        So we will need to change Parcel's ğŸ“¦
        behavior to acommodate and use BabelğŸ¦œ
        along with JestğŸƒ.

        ğŸ¤”But what are those changes? 
        According to Parcel'sğŸ“¦ documentation,
        you can make parcelğŸ“¦ ignore your Babel config.
        To disable Babel transpilation in
        Parcel, override the default parcel config
        for Javascript to exclude 
        `@parcel/transformer-babel.` inside 
        a `.parcelrc` file

        This will allow other tools to continue using
        your babel config, but disable BabelğŸ¦œ transpilation
        in parcelğŸ“¦. For this you need to create a new file
        called .parcelrc

                //ğŸ–¥ï¸inside .parcelrc
                    {
                    "extends": "@parcel/config-default",
                    "transformers": {
                        "*.{js,mjs,jsx,cjs,ts,tsx}": [
                        "@parcel/transformer-js",
                        "@parcel/transformer-react-refresh-wrap"
                        ]
                    }
                    }
        Now the Babel.js will not conflict with
        our previous config, the one we just wrote 
        will be the configğŸ—ï¸ will be using!!!!!!

        We now have configured our Project to write
        test-casesğŸ’¼.

        Â·But before we can write test-cases, we need to 
        write the JestğŸƒ configurationğŸ—ï¸
        


ğŸŸ¢-----Running JestğŸƒ-----â€¢Â·  

ğŸ¤”How do we run testğŸ§ª casesğŸ’¼?
Similar with how we run our application with npm
start, we will run our tests with a command 
inside our pakage.jsonğŸŠ file called "test".

            //ğŸ–¥ï¸inside pur terminal:
            > npm run test

        Since we haven't written ANY
        testğŸ§ª casesğŸ’¼, it will say 
        `No tests found,` but that means
        we have succesfully configured
        our 
            -React TestingğŸ§ªLibrary,
            -JestğŸƒ, 
            -BabelğŸ¦œ, 
            -ParcelğŸ“¦

        YaaayğŸ˜Š
    But before we can start writing test casesğŸ’¼
    we'll need to configureğŸ—ï¸ JestğŸƒ

                //ğŸ–¥ï¸inside the terminal:
                > npx jest --init

                //It will give us some questions to 
                create a suitable config for our project:

                -We will not be using Typescript for the 
                 configurationğŸ—ï¸ fileâœ–ï¸
                - we will be using jsdomğŸ“‘ for the 
                 TestingğŸ§ª enviromentâ˜‘ï¸

                    Â·jsdomğŸ“‘:
                     WHEN YOU WRITE CASES There's node
                     server, no browser, so we need an
                     enviromentğŸŒ± for our project.
                     To create an enviromentğŸŒ± we'll use
                     jsdomğŸ“‘.
                     jsdomğŸ“‘ is a library which parses 
                     and interacts with assembled 
                     HTML just like a browser.

                - we will choose for JestğŸƒ to add 
                  coverage reportsâ˜‘ï¸
                -The provider for coverage will be 
                BabelğŸ¦œâ˜‘ï¸
                -We will automattically clear mock calls
                , instances, contexts and results before
                every test â˜‘ï¸

    Now we have created our jest.config.js file according
    with the options we chose for our configurationğŸ—ï¸.

    Next, let's install our jsdomğŸ“‘ libraryğŸ“š. According
    with the documentation of TestingğŸ§ªLibrary, if we
    are using JestğŸƒ 28 or later, `jest-enviroment-jsdom`
    package now must be installed separatedly.

                //ğŸ–¥ï¸inside the terminal:
                > npm install --save-dev jest-environment-jsdom

    We will need to install more LibrariesğŸ“š in the future.


â­-------------------------------- Unit âºï¸ TestingğŸ§ª--------------------------------â­

ğŸŸ¢-----Writing testğŸ§ª casesğŸ’¼-----â€¢Â·

Let's write simple w test, some JavascriptğŸŸ¨ test.
For that, let's create a new componentğŸ§©, that will help us
to understand tesing. we will call it sum.js

                //ğŸ–¥ï¸inside sum.js
                export const sum = (a, b) =>{
                    return a + b
                }

    ğŸ¤”But how do we write testğŸ§ª casesğŸ’¼ for
    this component?
    If we write `npm run test` in the terminal,
    it says `No tests found`, JestğŸƒ was looking
    in all our files for testğŸ§ª casesğŸ’¼ and
    did not find any. But where is it searching?
    in the terminal you will find the answer in:

            //ğŸ–¥ï¸terminal returned:
             `testMatch: ğŸ‘‰**/__tests__/**/*.[jt]s?(x), **/?(
              *.)+(spec|test).[tj]s?(x) - 0 matches`

    JestğŸƒ was looking for thatâ¬†ï¸ folder.
    These files are present in a folder 
    that needs to be called `__test__`.

    Now, whatever files are present inside the our
    folder named __test__ğŸ“, it will track them.
    Now, like we saw, our testMatch has a configurationğŸ—ï¸
    for file extensions of .jt, jsx, or js. 

            //ğŸ–¥ï¸terminal returned:
                testMatch: **/__tests__/**/ğŸ‘‰*.[jt]s?(x), **/?(
                *.)+(spec|test).[tj]s?(x) - 0 matches`

    So any file you create, anywhere inside the folder
    structure, if is .js or jsx, it will be 
    considered a testğŸ§ª file

    otherwhise, if you can create a testğŸ§ª folder called
    .test.js or .test.ts, etc
    For example you can create Header.test.js as a test 
    file or you can also use

        Â· Headers.test.ts
        Â· Headers.spec.js
        Â· Headers.spect.js

    All those files will be considered testing files

        ğŸ¤”But what is that `__` business?
        that is syntax for dunder method of
        python, and we use it as a keyword,
        it's a convrnyion. for testsğŸ§ª, a
        reserved word for tracking testing files.

ğŸŸ¢-----creating our first JavascriptğŸŸ¨ testğŸ§ª file-----â€¢Â·

    Let's create our first testğŸ§ª file inside our __test__ğŸ“
    folder to test our sum.js componentğŸ§©. called sum.test.js

    ğŸ¤”How are we going to test our sum function?

        â€¢FIRST of all, we use a functionğŸ“½ï¸ `test`
        that takes 2 arguments, a string and a callback
        function. The string will describe the purpose of
        the function we are testing, and inside the brackets 
        of the function it will be the test. This is the rest

                //ğŸ–¥ï¸inside sum.test.js
                import { sum } from "../sum"

                    ğŸ‘‰test("sum function should sum of two numbers", ()=>{

                        //first we will call the function we want to test:
                        ğŸ‘‰const result = sum(3,4)//using some parameters

                        //this line is known as ASSERTIONğŸ«¡:
                        ğŸ‘‰expect(result).toBe(7)
                        
                        //the result has to be the same as the toBe method
                    })


        now we can run the test using `npm run test` in the terminal 
        and it will tell us that our test passed!

                //ğŸ–¥ï¸terminal returned:
                    ...
                    Test Suites: 1 passed, 1 total
                    Tests:       1 passed, 1 total
                    ...

        â—Most of the time, you will
        always have ASSERTIONsğŸ«¡ in your test, if you don't write
        an ASSERTIONğŸ«¡, it will always pass no matter what.


    ğŸŸ¢-----creating our first REACTâš›ï¸ testğŸ§ª file-----â€¢Â·

    We will be writing unit testing.
    First of all, let's run our app in a different terminal than our TestingğŸ§ª
    one. using `npm run start`.
    Let's create a basic testğŸ§ª to see if our componentğŸ§© is loaded or not. 

    We'll be using our Contact.js componentğŸ§©
    we'll try to render it, and see if it loads or not.
    But first let's fill a little bit our componentğŸ§©, since 
    it's looking quite empty.

                    //ğŸ–¥ï¸inside .parcelrc
                    const Contact = () => {
                        return (
                            <div>
                                <h1>Contact us page</h1>
                                <form>
                                <input type="text"
                                placeholder="name" />

                                <input type="text"
                                placeholder="message" />

                                <button>Submit</button>
                                </form>
                            </div>
                        );
                    }
                    export default Contact;


        â€¢ Now is time to write the test, inside a new
        componentğŸ§© inside our __test__ğŸ“ folder we
        will call `Contact.test.js`:

                    //ğŸ–¥ï¸inside .parcelrc

                    import { render, screen } from "@testing-library/react"
                        import Contact from "../Contact"

                        test(
                            "should load contact.js component", () => {

                            ğŸ‘‰render(<Contact />)//this wil render it to 
                            the js DOM

                            /*Now we will test it if it was successfully 
                            rendered:
                            For that we will use the screen() method
                            screen is an obj that comes from the 
                            testing library
                            that give us access to the component elements*/

                            /*Thanks to the screen obj, we can use the 
                            getbyRole
                            method to find all the elements with a 
                            given role value: */

                            ğŸ‘‰const heading = screen.getByRole("heading")

                            /*Now that we got our element, we can expect some results
                            by manipulating it */

                            ğŸ‘‰expect(heading).toBeInTheDocument()
                        })

        ğŸ¤”However, this test has failed, but why?
        in the terminal it shows `Support for the experimental syntax '
        jsx' isn't currently enabled`

        so JSXğŸ¦ is not enabled for our app!

        ğŸ¤”How can we enable JSXğŸ¦??
        in the terminal it shows ` Add @babel/preset-react `, So JestğŸƒ
        is helping us to solve this issue

                    //ğŸ–¥ï¸inside the terminal:
                    //For enabling JSXğŸ¦ â¬‡ï¸

                    >npm i -d @babel/preset-react

        And we will need to Include @babel/preset-react 
        inside  my BabelğŸ¦œ configğŸ—ï¸:

                    //ğŸ–¥ï¸inside babel.config.js :
                    module.exports = {
                    presets: [['@babel/preset-env', {
                        targets: { node: 'current' } }]
                        
                        /*it will automatically pick the runtime,
                            If we don't add the runtime thing, wit will
                            pick an error: â¬‡ï¸*/

                            ğŸ‘‰["@babel/preset-react", { 
                                runtime: "automatic" }]
                        
                        ],
                    };

        ğŸ¤”Why do we need this preset??
        basically, BabelğŸ¦œ is a transpiler. Right 
        now this Babel preset in react is helping
        the TestingğŸ§ªLibraryğŸ“š to convert the JSXğŸ¦
        code to XTML/html so it can read it properly

        But it continues to fail ğŸ˜­, why????
        in the terminal says `TypeError: expect(...
        ).toBeInTheDocument is not a function`

        This is because we haven't installed the 
        libraryğŸ“š for toBeInTheDocument().
        This libraryğŸ“š is jest-dom


                    //ğŸ–¥ï¸inside the terminal:
                    npm i -D @testing-library/jest-dom

        when is fixed, we can import the library to our testğŸ§ª
        file:
                    //ğŸ–¥ï¸inside Contact.test.js:
                    import "@testing-library/jest-dom";

        Once the libraryğŸ“š is included, as soon as you
        write anu ASSERTIONğŸ«¡, (an expect statement)
        vscode suggest you a lit of methods that we can
        use to testğŸ§ª our selected element.

        This time the testğŸ§ª passedâœ…

        â€¢ Let's make a render testğŸ§ª for our Submit buttonğŸ”˜.

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load button inside contact.js component", () => {

                    render(<Contact />)//this wil render it to the js DOM

                    const button = screen.getByRole("button")

                        expect(button).toBeInTheDocument();
                    })

        Â· So with this line:
        `const heading = screen.getByRole("heading")`
        the getByRole method can help you with every kind of role in the html
        this roles are defined by JestğŸƒ inside the TestingğŸ§ªLibraryğŸ“š
        there's more ways to access our button, we can also use

            - screen.getByText("Submit")
                this will look for matches of text in our screen 
                object and find our `Submit` buttonğŸ”˜

        If you try to find a non-existent eleement, the testğŸ§ª wil fail

        The beauty of JestğŸƒ is that, whenever it fails, the test, it 
        will show you what was rendered so you can see it for reference

        â€¢ Let's make a render testğŸ§ª for our placeholder text inside our
        input attribute:

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load the name input inside contact.js component", () => {

                        render(<Contact />)//this wil render it to the js DOM

                        const input = screen.getByPlaceholderText("name")

                        expect(input).toBeInTheDocument();
                    })

        â€¢ What we would do if we wanted to get Multiple the input attributes:

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load 2 input boxes inside contact.js component", () => {

                        render(<Contact />)

                        //there's not role named "input", the appropiate term is "textbox:"
                    ğŸ‘‰ const inputBoxes = screen.getByRole("textbox")


                        expect(inputBoxes).toBeInTheDocument();
                    })
        
                â—However, this will throw an error saying there are multiple elements 
                with the role "textbox" ğŸ˜± why??
                because the appropiate method to check ALL the elements with the same 
                role is getAllByRole().
                Let's use it and log into the console what do we get using this method:

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load 2 input boxes inside contact.js component", () => {

                        render(<Contact />)

                        //This is known as queryingğŸ™‹â€â™€ï¸ the getByAll()
                        const inputBoxes = screen.getAllByRole("textbox")

                        //intputBoxes will be an array of objects
                        //here we log the first element of the array:
                        console.log(inputBoxes[0])
                    })

                We get a react element with all its properties. Remember that at the
                end of the day JSXğŸ¦ is a way to write REACTâš›ï¸ elements and 
                REACTâš›ï¸ elements are OBJECTS!

                If we are queryingğŸ™‹â€â™€ï¸ we do something like screen. and add a get
                method and make things return to us!

                Now let's check with our ASSERTIONğŸ«¡ if we actually have 2 input
                boxes:

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load 2 input boxes inside contact.js component", () => {

                    render(<Contact />)

                    const inputBoxes = screen.getAllByRole("textbox")

                    //since our inputBoxes is an array of objects:
                    ğŸ‘‰expect(inputBoxes.length).toBe(2)
                })

                Â· We can also check a FALSE amount using the `not` keyword:
                - expect(inputBoxes.length).not.toBe(3)
        
    These were only the basics of TestingğŸ§ª, some important things:

    ğŸš¨Remember: when TestingğŸ§ª you will allways need to

        1ï¸âƒ£ RENDERğŸ–Œï¸ something
        2ï¸âƒ£ QUERYğŸ™‹â€â™€ï¸ something
        3ï¸âƒ£ ASSERTğŸ«¡ something

    ğŸš¨Remember that `test()` is the name of the function, you can 
    also use `it` like this: 

                //ğŸ–¥ï¸inside Contact.test.js:
                    ğŸ‘‰it("should load 2 input boxes inside contact.js component", () => {
                    ...
                })

        There's no Difference!!!!!! it() is just an alias of test()

    ğŸš¨Remember to hover over the methods in VSCODE if you don't understand any,
    it will typically provide explanations on how the code works

ğŸŸ¢-----Managing Multiple testğŸ§ª casesğŸ’¼ USING describeğŸ–‹ï¸-----â€¢Â·

    We have now written several testğŸ§ª casesğŸ’¼
    Sometimes the number of testsğŸ§ª becomes unmanageable,
    in that circumstance, we can put them in group, 
    that means, puting all the testğŸ§ª casesğŸ’¼ inside
    a block code  named describeğŸ–‹ï¸.

    Let's use describeğŸ–‹ï¸ to contain all our Contact.js
    testğŸ§ª cases:

                //ğŸ–¥ï¸inside Contact.test.js:
                describe("Contact us Page test cases", () => {

                test("should load contact.js component", () => {...})

                test("should load the name input inside contact.js component", () => {...})

                test("should load 2 input boxes inside contact.js component", () => {...})

                });


        ğŸš¨Everything works the same, this is just for grouping testsğŸ§ª

        â•you can also nestğŸªº one describeğŸ–‹ï¸ in another describeğŸ–‹ï¸
        â•You can have multiple describeğŸ–‹ï¸ in a single file
        â•



ğŸŸ¢-----CoverageğŸ“-----â€¢Â·

As we can see inside our projects,t there are many more files
than before. This is because our CoverageğŸ“ and the new files
it contains, it was added with JestğŸƒ in order to have the 
capacity to cover all our files in our TestingğŸ§ª

This file is inside our Dependenciesâ›“ï¸ so is not necessesary
to push it to our GitğŸˆâ€â¬› repository, so we can put it inside
our `.gitignore` file:


                //ğŸ–¥ï¸inside Contact.test.js:
                /node_modules/
                /dist/
                /.parcel-cache/
                ğŸ‘‰/coverage/


ğŸŸ¢-----TestingğŸ§ª our Header componentğŸ§©-----â€¢Â·

    ğŸš¨Remember that we are making Unit TestingğŸ§ª, now we are going to test
    our header componentğŸ§© to see if:

        - It loads the LoginğŸ” buttonğŸ”˜
        - our CartğŸ›’ element starts with 0 elements inside

    so to start, we create a new testing file called Header.test.js

                //ğŸ–¥ï¸inside Header.test.js:
                describe("Contact us Page test cases", () => {
    
                    it("Should load Header Component with a 
                    login button", ()=>{
                        render(
                            <Header/>
                        )
                    })
                })

    â—However, this throws an ERROR, that is because our CartğŸ›’
    functions with Redux, so we will have to provide Redux to our
    componentğŸ§© using <Provider> and provide our appStore
    so it has access to our Redux code

                //ğŸ–¥ï¸inside Header.test.js:
                describe("Contact us Page test cases", () => {
    
                    it("Should load Header Component with a 
                    login button", ()=>{
                        render(
                            <Provider store={appStore}>
                            <Header />
                            </Provider>
                        )
                    })
                })


    â—This throws an ERROR, because the Link element is not
    supported by JestğŸƒ, since we got it from ROUTERğŸ›£ï¸ we will need to wrap
    our testğŸ§ª inside that feature:


                //ğŸ–¥ï¸inside Header.test.js:
                    import { render } from "@testing-library/react";
                    import { Provider } from "react-redux";
                    import appStore from "../../../utils/redux/appStore.js";
                    import Header from "../Header";
                    import { BrowserRouter } from "react-router-dom";

                    it("Should load Header Component with a login button", () => {
                        render(
                            <BrowserRouter>
                                <Provider store={appStore}>
                                    <Header />
                                </Provider>
                            </BrowserRouter>
                        );
                    });
                        

    Now that we can RENDERğŸ–Œï¸ Properly, is time to QUERYğŸ™‹â€â™€ï¸ and ASSERTğŸ«¡:


                      //ğŸ–¥ï¸inside Header.test.js:
                   ...
                    it("Should load Header Component with a login button", () => {
                        render(
                            <BrowserRouter>
                                <Provider store={appStore}>
                                    <Header />
                                </Provider>
                            </BrowserRouter>
                        );
                        ğŸ‘‰const  login = screen.getByRole("button")
                        //const loginButton = screen.getByText("Login") â¬…ï¸is also correct
                        //but you should use Role

                        ğŸ‘‰expect(login).toBeInTheDocument();
                    });
    
    If there are multiple buttons and you only need the LoginğŸ” one, this is a
    way to single it out:

                          //ğŸ–¥ï¸inside Header.test.js:
                            ...
                            it("Should load Header Component with a login button", () => {
                                render(
                                ...
                                );
                                ğŸ‘‰const  login = screen.getByRole("button", {name: "Login"})

                                expect(login).toBeInTheDocument();
                            });


    â€¢ CartğŸ›’ TestğŸ§ª caseğŸ’¼:

    Let us find out if the CartğŸ›’ componentğŸ§© start empty: 
    

                              //ğŸ–¥ï¸inside Header.test.js:
                            ...
                            it("Should load Header Component with no cart items", () => {
                            render(
                                <BrowserRouter>
                                    <Provider store={appStore}>
                                        <Header />
                                    </Provider>
                                </BrowserRouter>
                            );

                            ğŸ‘‰const  cartItems = screen.getByText("ğŸ›’ (0 items)")

                            ğŸ‘‰expect(cartItems).toBeInTheDocument();
                        });

    - But what if we want to check if there's a CartğŸ›’ componentğŸ§©? in that case we can use
    a regex to match part of the text without exactly getting it, like this

                                  //ğŸ–¥ï¸inside Header.test.js:
                            ...
                            it("Should load Cart Component inside Header", () => {
                            render(
                                <BrowserRouter>
                                    <Provider store={appStore}>
                                        <Header />
                                    </Provider>
                                </BrowserRouter>
                            );

                            ğŸ‘‰const  cart = screen.getByText(/ğŸ›’/)

                            expect(cart).toBeInTheDocument();
                        });

    â€¢ LoginğŸ” text change TestğŸ§ª caseğŸ’¼:

        Our app changes the Login text everytime we click, on it, let's testğŸ§ª this feature:

                             //ğŸ–¥ï¸inside Header.test.js:
                                  ...
                                    it("Should change Login button to Logout on Click", () => {
                                render(...);
                                    //Getting the LoginğŸ” button
                                ğŸ‘‰const loginButton = screen.getByRole("button", {name: "Login"});

                                    //we can use fireEvent this to check on Events
                                    //first we need to import it from "@testing-library/react"
                                    //syntax: fireEvent.eventThatWillFire(place where my event should fire):
                                ğŸ‘‰fireEvent.click(loginButton)

                                    //Now let's access the logout button that we changed to:

                                    ğŸ‘‰const logoutButton = screen.getByRole("button", {name: "Logout"});

                                    /*If the event was fired succesfully, we will expect the  Logout
                                    Button to be in the document:*/
                                    
                                ğŸ‘‰expect(logoutButton).toBeInTheDocument();
                            });

ğŸŸ¢-----TestingğŸ§ª our Restaurant Card componentğŸ§© -----â€¢Â·

    Let's check if we can test our RestaurantCard componentğŸ§© considering that
    props are being passed inside:

    for that we will create MockDatağŸ­ to pass it like props, and see if it's working

    that MockDatağŸ­ will be in a separate folder called mocksğŸ“
    inside we will make a file to test our RestaurantCard componentğŸ§©, "resCardMock.json"
    that will contain an object similar to the ones that are inside of the array of
    the restaurant menu array:



                             //ğŸ–¥ï¸inside Header.test.js:
                                {
                                    "id": "71579",
                                    "name": "Hotel Inayat Cafe",
                                    "avgRating": 4.2,
                                    "cuisines": [
                                    "North Indian",
                                    "Biryani",
                                    "Chinese"
                                    ],
                                    "promoted": true,
                                    "sla": {
                                    "deliveryTime": 25,
                                    "lastMileTravel": 2.3,
                                    "serviceability": "SERVICEABLE",
                                    "slaString": "25 mins",
                                    "lastMileTravelString": "2.3 km",
                                    "iconType": "ICON_TYPE_EMPTY"
                                    },
                                    "cloudinaryImageId": "jvuhbo6nvyt8tsiwkll6"
                                }

    We will RENDERğŸ–Œï¸ our Header componentğŸ§©  inside our test, and pass the MockDatağŸ­
    as a prop. Later, we will get one of the text elements inside it to see if it was
    passed succesfully.


                             //ğŸ–¥ï¸inside Header.test.js:
                                it("Should render RestaurantCard Component with props Data", () => {

                                    render(<RestaurantCard resData={MOCK_DATA} />);

                                    console.log(screen)

                                    //checking if we can find the name property:

                                    const name =  screen.getByText("Hotel Inayat Cafe")
                                    

                                    expect(name).toBeInTheDocument(); 
                                });


    Now 



â­--------------------------------IntegrationğŸš¸ TestingğŸ§ª--------------------------------â­

ğŸŸ¢-----Writing testğŸ§ª casesğŸ’¼ for IntegrationğŸš¸ testing on the Body componentğŸ§©-----â€¢Â·

let's testğŸ§ª our SearchğŸ” feature that is inside our body component
For that we will create a testğŸ§ª file inside our __test__ğŸ“ folder
Inside our search let's first render the whole Body.js componentğŸ§©

An important part of our Body component is making an API call.
we will later write testğŸ§ª casesğŸ’¼ for that scenario

    But firslt, let's render the whole body componentğŸ§© and checking if my
    SearchğŸ” button is there, we will write the IntegrationğŸš¸ test later:

                             //ğŸ–¥ï¸inside Search.test.js:
                            it(
                            "Should render RestaurantCard Component with props Data", (

                            ) => {
                            render(<Body/>)
                            })

    â—However, this returns an ERRORâŒ, it fails beause "ReferenceError: fetch is not defined"
    ğŸ¤”Why? when you testğŸ§ª the Body componentsğŸ§©, is not rendering it on the BrowserğŸŒ, 
    it is rendering in the JestğŸƒ jsdomğŸ“‘ which is obly BrowserğŸŒ-like, meaning it doesn'takes
    have ALL the browser's super powers, FetchğŸ• is a superpower in the browser, is not a native
    function of JavascriptğŸŸ¨, is kinda like an API inside JavascriptğŸŸ¨ but not native! JestğŸƒ
    does not understand fetch. 

    So we will need to use a mock functionğŸ“½ï¸ for our test,
    This is how we write it 

                             //ğŸ–¥ï¸inside Search.test.js:

                                /*global object that will replace the fetch function,
                                we are defining it inside a global object
                                And we will define our data as a jest function: â¬‡ï¸ */
                                    global.fetch = jest.fn(() =>{
                                        //our jest function takes a callback function:
                                        //Here we will mock how our fetch function works inside Body.js
                                        /*Our fetch function returns a promise, so we will need to 
                                        /return a promise function: */
                                        return Promise.resolve({
                                            // now it resolves the promise
                                            //and is resolved thru a json:
                                            //and json is a function that returns  another promise:
                                            json: ()=>{
                                                //this json returns also a promise that needs resolve:
                                                //and this promise actually has data that will be 
                                                //...mock data:
                                                â¡ï¸return Promise.resolve(MOCK_DATA)
                                            }
                                        })
                                    })

    For this to work we will need to create more MockDatağŸ­ inside a file that we will call
    mockResListData.json and import it as `MOCK_DATA`. This is how our file looks now:

                             //ğŸ–¥ï¸inside Search.test.js:
                                import { render, screen} from "@testing-library/react"
                                import MOCK_DATA from "../../mocks/mockResListData.json"
                                
                                    global.fetch = jest.fn(() =>{
                                        return Promise.resolve({
                                            json: ()=>{
                                            return Promise.resolve(MOCK_DATA)
                                            }
                                        })
                                    })
                                it("Should render Body component, () => {
                                    render(<Body/>)
                                    })`

        And the test passedâœ… but with a warningâš ï¸, which tell us that every time 
        we make an async operation or doing a stateâ˜ï¸ we need to write our RENDERğŸ–Œï¸
        method wrapped in an act function.
        This is the warningâš ï¸:

             `Warning: An update to Body inside a test was not wrapped in act(...).
                When testing, code that causes React state updates should be wrapped into act(...):
                act(() => {
                    /* fire events that update state */
                });`

        ğŸš¨ This act()ğŸ‘©ğŸ»â€ğŸ¤ function is coming from `react-dom/test-utils`, and we need to 
        import it from there.

                             //ğŸ–¥ï¸inside Search.test.js:
                                ...
                                import { act } from "react-dom/test-utils"
                                
                                    global.fetch = jest.fn(() =>{
                                        ...
                                    })
                                it("Should render RestaurantCard Component with props Data", async () => {
                                //we need to render our react elements inside an act() function,
                                //the act() function will return a promise:
                                //Since we return a promise, we'll need to use await.
                                //since we use await, we need to use async

                                ğŸ‘‰await act( async ()=> { render(<Body/>)});

                                // an act function returns a callback that is also asyncâ¬†ï¸
                                //and will render our component.
                            })

                However, this will throw an ERRORâŒ: 
                `The above error occurred in the <Link> component:`
                we already know how to solve this issue, we just wrap our componentğŸ§©
                inside our BrowserRouter

                             //ğŸ–¥ï¸inside Search.test.js:
                                ...
                                import { BrowserRouter } from "react-router-dom";
                                
                                    global.fetch = jest.fn(() =>{...})
                                it("Should render Body component, () => {
                                    await act( async ()=> { render(
                                        <BrowserRouter>
                                        <Body/>
                                        </BrowserRouter>
                                    )});
                                    })`


                Now our testğŸ§ª passedâœ…, We have rendered our componentğŸ§© succesfully, it's
                time to QUERYğŸ™‹â€â™€ï¸ and  ASSERTğŸ«¡ our SearchğŸ” button:

                             //ğŸ–¥ï¸inside Search.test.js:
                                ...
                                it("Should render search button", async(

                                ) => {
                                    await act( async ()=> { render(
                                        <BrowserRouter>
                                        <Body/>
                                        </BrowserRouter>
                                    )});

                                    const searchBtn =  screen.getByRole("button", {name: "Search"})

                                    expect(searchBtn).toBeInTheDocument();
                                })

        â€¢ Tip: 
        ğŸ’¡To avoid runing the testsğŸ§ª again and again using "npm run test"
        we can add a new script to our package.jsonğŸŠ file called
        "watch-test" so every time we save our project, it tests it 
        automatically:

                             //ğŸ–¥ï¸inside package.jsonğŸŠ
                             {
                                ...
                                "scripts": {
                                    "start": "parcel index.html",
                                    "build": "parcel build index.html",
                                    "test": "jest",
                                    â¡ï¸"watch-test": "jest --watch"
                                }
                                }

                -and then writing on terminal: `npm run watch-test`
                Watch Usage
                â€º Press a to run all tests.
                â€º Press f to run only failed tests.
                â€º Press p to filter by a filename regex pattern.
                â€º Press t to filter by a test name regex pattern.
                â€º Press q to quit watch mode.
                â€º Press Enter to trigger a test run.


        â€¢ Now let's make a testğŸ§ª by writing something inside the input 
        area of the search button, using a new method called getByTestId.
        We will add a new attribute called "data-testId" which value will
        be the ID we want to give to that input element:

                             //ğŸ–¥ï¸inside Body.js
                             ...
                             <div className="search">
                            <input 
                            className="rounded-sm p-1 w-60"
                                type="text" 
                                ğŸ‘‰data-testid = "searchInput"
                                placeholder="Type a meal..."
                                value={searchText}
                                onChange={(e) => {
                                    setsearchText(e.target.value)
                                }}
                            />
                             ...

        Now we access the input element through our data-testid

                             //ğŸ–¥ï¸inside Search.test.js:
                             it("Should render input box text", async () => {
                                await act( async ()=> { render(
                                    <BrowserRouter>
                                    <Body/>
                                    </BrowserRouter>
                                )});

                                const searchInput =  screen.getByTestId(searchInput)
                            });


        It's time to type something in our testğŸ§ª to see if it works, but ğŸ¤”How
        can we do that? we will need to trigger an event using fireEvent(), and
        inside, simulate changing the value inside the input box like we made
        inside our Body componentğŸ§© using e.target.value

                             //ğŸ–¥ï¸inside Search.test.js:

                             it("Should search Res list for pizza using text imput", async () => {
                                await act( async ()=> { render(
                                    ...
                                )});

                                const searchInput =  screen.getByTestId("searchInput")

                                //fireEvent will recieve our searchInput
                                //and pass an object that will simulate what we get 
                                //inside the event.
                                ğŸ‘‰fireEvent.change(searchInput, {target: {value: "pizza"}});
                            });

        Now let's simulate clicking the SearchğŸ” button to actually testğŸ§ª our 
        functionality. For that we will need to use fireEvent() and get our button
        clicked. After that, according to our data, we can expect 2 cards to
        appear inside our body componentğŸ§©.

        ğŸ¤”How can we check on that? well, at the end of the day, each Card is
        a <div> element.
        ğŸ¤”How can we access it inside my test?
        We can use testId in order to count them.


                            //ğŸ–¥ï¸inside RestaurantCard.JSğŸŸ¨
                                ...
                                const RestaurantCard = (props) => {
                                ...
                                    
                                    return (
                                        <div 
                                        ğŸ‘‰data-testid = "resCard"
                                        ...
                                        </div>
                                    );
                                }

        Now, with getAllByTestId() we can get all the cards on the screenğŸ“º, 
        using the TestId attribute. since we have only 2 "pizza" related cards, 
        The length of the array returned by getAllByTestId()  should equal 2


                            //ğŸ–¥ï¸inside Search.test.js
                            it("Should search Res list for pizza using text imput", async () => {
                            await act( async ()=> { render(
                                ...
                            )});

                            const searchBtn =  screen.getByRole("button", {name: "Search"})
                            const searchInput =  screen.getByTestId("searchInput")

                            fireEvent.change(searchInput, {target: {value: "pizza"}});
                            fireEvent.click(searchBtn)

                            //ASSERT: Screen should load 2 cards: 
                            ğŸ‘‰const cards  =  screen.getAllByTestId("resCard")

                            ğŸ‘‰expect(cards.length).toBe(2)
                        });


            It passedâœ…!

        Just to have our testğŸ§ª more rounded, let's check if it's delivering the 
        correct amount of cards that we want to display inside our Body componentğŸ§©.
        In this case, they are 20 in total. So before our click event we add:

                        //ğŸ–¥ï¸inside Search.test.js
                            it("Should search Res list for pizza using text imput", async () => {
                            await act( async ()=> { render(
                                ...
                            )});

                            const searchBtn =  screen.getByRole("button", {name: "Search"})
                            const searchInput =  screen.getByTestId("searchInput")

                            ğŸ‘‰const cardsBeforeSearch = screen.getAllByTestId("resCard")
                            ğŸ‘‰expect(cardsBeforeSearch.length).toBe(20)

                            fireEvent.change(searchInput, {target: {value: "pizza"}});
                            fireEvent.click(searchBtn)

                            const cardsAfterSearch   =  screen.getAllByTestId("resCard")

                            expect(cardsAfterSearch.length).toBe(2)
                        });

            Once again, our tests passedâœ…!

        â€¢ Let's test one last feature, our Top Restaurants button, to see if it filters
        the top restaurants:

                        //ğŸ–¥ï¸inside Search.test.js
                            it("Should filter the top rated restaurants", async()=>{
                            await act(async ()=>{
                            render(
                                <BrowserRouter>
                                <Body/>
                                </BrowserRouter>
                            )});

                            //let's check our  number of cards before filteringâ¬‡ï¸:
                            const cardsBeforeFilter = screen.getAllByTestId("resCard")
                            expect(cardsBeforeFilter.length).toBe(20)

                            //finding the button and clicking itâ¬‡ï¸:
                            const topRatedBtn = screen.getByRole("button", {name: "Top Rated Restaurants"})
                            fireEvent.click(topRatedBtn)

                            const cardsAfterFilter = screen.getAllByTestId("resCard")

                            //getting the filtered cardsâ¬‡ï¸:
                            expect(cardsAfterFilter.length).toBe(10)
                    })

            Once again, our tests passedâœ…!


ğŸŸ¢-----beforeAll(), beforeEach(), afterAll(), afterEach()-----â€¢Â·

    Helper functionsğŸ“½ï¸ that can help us to manage testsğŸ§ª: 

    Â· beforeAll(). Suppose that you have a describe(...) block of tests,
    and you will like to perform some action ONCE, before all of them start
    to execute. You can use the beforeAll() function inside the block
    and on the top of all testsğŸ§ª.
    It takes a callback function, and whatever you want to pass inside
    the callback it will execute.

    Â· beforeEach() works the same, except it will execute before EACH test,
    one time for each of the tests. So it's very helpful if we have to 
    do some cleanup task

    Â· afterAll() : similarly to beforeAll(), this functionğŸ“½ï¸ executes 
    once after ALL the test have been executed 

    Â· afterEach() like beforeEach() it executes one time for each test
    after it has been executed 


                //ğŸ–¥ï¸inside Contact.test.js:
                describe("Contact us Page test cases", () => {

                    //Will run the function Before ALL the testsğŸ§ª
                    ğŸ‘‰beforeAll(()=>{
                        console.log("Before All")
                    });

                    ğŸ‘‰beforeEach(()=>{
                        console.log("Before each")
                    })


                test("should load contact.js component", () => {...})

                test("should load the name input inside contact.js component", () => {...})

                test("should load 2 input boxes inside contact.js component", () => {...})

                });
ğŸŸ¢-----Writing testğŸ§ª casesğŸ’¼ for IntegrationğŸš¸, CartğŸ›’ componentğŸ§©-----â€¢Â·

    Let's test a very important functionality inside our app, our CartğŸ›’ componentğŸ§©.
    And if we are able to add things to our CartğŸ›’.

    We'll start by creating a new testğŸ§ª file called `Cart.test.js`
    then we'll create mock data for a restaurant in a file called `resCardMock.json"

    and FetchğŸ• The MockDatağŸ­ using the act() functionğŸ“½ï¸, rendering wraping our
    componentğŸ§© inside our BrowserRouter.

    Inside this test file, we will mock rendering a Restaurant Menu, clicking 
    an item inside one of the menu sections, and adding it to the cart, let's
    start by just RENDERğŸ–Œï¸ the Restaurant Menu using a mock data file that
    we will call `mockResMenu.js`, we will import it using a fetch function of
    our own, like we did before with SearchğŸ”


                //ğŸ–¥ï¸inside Cart.test.js:

                    import MOCK_DATA_MENU from "../../mocks/mockResMenu.json";

                    global.fetch = jest.fn(()=>
                    Promise.resolve({
                        json: () => Promise.resolve(MOCK_DATA_MENU)
                    })
                    );

            Now is time to RENDERğŸ–Œï¸ our RestaurantMenu componentğŸ§©.
            Just like before, we will need to wrap it inside an 
            act() function that will be async.
            Inside it we will need to Provide the Redux appstore that
            makes our cart work, otherwise it will throw an ERRORâŒ
            and also, we need to wrap it inside our BrowserRouter for our
            Links to work:


                //ğŸ–¥ï¸inside Cart.test.js:
                 ...
                    it("should Load Restaurant Menu Component", 
                    async () => {
                        await act(async () =>
                        render(
                            <BrowserRouter>
                            <Provider store={appStore}>
                                <RestaurantMenu />
                            </Provider>
                            </BrowserRouter>
                        )
                        );

                    });

            Let's do a couple of things:
            1ï¸âƒ£ simulate that we are clicking the "Extras"
            category inside our accordion that is inside
            our Menu
            2ï¸âƒ£Clicking our accordion header to open it

                //ğŸ–¥ï¸inside Cart.test.js:
                 ...
                    it("should Load Restaurant Menu Component", 
                    async()=>{
                    await act(...)
                        //queryingğŸ™‹â€â™€ï¸ the menu:
                    1ï¸âƒ£const accordionHeader = screen.getByText(
                        "Extras (4)")
                    2ï¸âƒ£fireEvent.click(accordionHeader);
                    });

        Now we want to get ALL the items that are inside our
        `Extras` we can get them all assigning TestId for
        each item of our list, inside of our ItemList component.
        our TestId will be "foodItems". For this category, we 
        should have an array of 4 foodItems

                        //ğŸ–¥ï¸inside Cart.test.js:
                 ...
                    it("should Load Restaurant Menu Component", 
                    async()=>{
                    await act(...)
                    ...
                    const foodItems = screen.getAllByTestId(
                        "foodItems")
                    expect(foodItems.length).toBe(4)
                    });

        The next thing we will need to do is to simulate clicking
        the first addâ• button of our food items
        and check if our CartğŸ›’ componentğŸ§© inside our Header, 
        componentğŸ§©,
        where it counts the items that have been added to our Cart,
        has updated

         //ğŸ–¥ï¸inside Cart.test.js:
                 ...
                   it("should Load Restaurant Menu Component", async () => {
                    await act(async () =>
                    //Importing our header:
                    render(
                        <BrowserRouter>
                        <Provider store={appStore}>
                            <RestaurantMenu />
                           ğŸ‘‰ <Header/>
                        </Provider>
                        </BrowserRouter>
                    )
                    );
                    ...
                    //Getting the addâ• buttons:
                    ğŸ‘‰const addBtns =  screen.getAllByRole("button", {name: "Add +"})

                    //Clicking the first addâ• button of our array:
                   ğŸ‘‰ fireEvent.click(addBtns[0])

                   //Checking if the Header has been updated:
                    ğŸ‘‰expect(screen.getByText("ğŸ›’ (1 items)")).toBeInTheDocument()
                });

        TipğŸš¨
        ğŸ’¡Always create separate tests, instead of puting them all inside
        a single one like we did hereğŸ’¡


                //ğŸ–¥ï¸inside Cart.test.js:
                    it("should render Cart component with 2 items", async () => {
                    await act(async () =>
                    render(
                        <BrowserRouter>
                        <Provider store={appStore}>
                            ğŸ‘‰<Cart/>
                            <RestaurantMenu />
                            <Header/>
                        </Provider>
                        </BrowserRouter>
                    )
                    );

                    const accordionHeader = screen.getByText("Extras (4)")

                    fireEvent.click(accordionHeader)

                    const addBtns =  screen.getAllByRole("button", {name: "Add +"})

                    fireEvent.click(addBtns[0])

                    fireEvent.click(addBtns[1])

                    /* Counting our foodItems including the ones in the 
                    Restaurant Menu(4), 
                    header(2)
                    and the cart component(2)*/
                    ğŸ‘‰expect(screen.getAllByTestId("foodItems").length).toBe(8);

                    //checking our "Clear Cart button"
                    ğŸ‘‰fireEvent.click(screen.getByRole("button", {name : "Clear Cart"}))
                    //Now only RestaurantMenu is rendering the 4 foodItems insde `Extras`
                    ğŸ‘‰expect(screen.getAllByTestId("foodItems").length).toBe(4);
                    //checking if cart component is empty:
                    ğŸ‘‰expect(screen.getByText("Cart is empty")).toBeInTheDocument()

                    })

ğŸŸ¢-----Checking our CoverageğŸ“

Inside our terminal we can see that our tests have a coverage
of 94% inside our app, to check where some coverage is missing,
we can look at the CoverageğŸ“ folder, then go to 
Icov-report > index.html and open with
