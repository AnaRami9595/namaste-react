🟢-----Developer Testing🧪-----•·

Here we are going to talk about different ways
to test our application. 

    • Manual testing👌🏽:
        the practice of checking if your code 
        works and the features are functional.
        this is not very efficient, because if\
        you change the code a little you will 
        need to get back and chec if works.

        Whenever we add a line ri our code, 
        that can introduce bugs in our app
        ANYWHERE. This is specially complicated
        if your'e building a large scale app.

        That's why Testing🧪 is very important

    •  Test Code⌨️
        Writing test cases💼 to prove our app
        works. It will test our application
        automatically, this is what we are 
        going to do today.

            Types of DEV🤓 case💼 Testing🧪:

                · Unit ⏺️Testing🧪
                · Integration🚸 Testing🧪
                · End to End🔚 testing (e2e)

    
🟢-----TYPES of DEV🤓 Testing🧪-----•·

    • Unit ⏺️Testing🧪
      You test your REACT⚛️ components in 
      isolation. If you want to test the 
      header component🧩, you will try To
      render your header component🧩 in
      isolation to the rest of the app.
      
    • Integration🚸 Testing🧪
      Testing🧪 the Integration🚸 between
      the components🧩, all of them are 
      colaborating to make a feature, 
      you will develop a flow of their 
      colaboration, how are they talking to 
      each other  

    • End to End🔚 testing (e2e)
      It means testing a REACT⚛️ app as 
      soon as the user enters the react
      application until he leaves it,
      checking all the flows. Starts
      on the landing and how the user
      will flow across the app. 
    
    End🔚 to End🔚 testing requires
    different kind of Tools🔨, so will be
    only concerned with the first two. 



    🔹💡Interview question💡
        Testing🧪 is now considered as part of 
        the developer job. Testing is part of 
        writing code. Make this a habit.

    
🟢-----REACT TESTING LIBRARY🧪📚-----•·  

        • is the most common way of testing
        REACT⚛️ code. It is build on top of
        "DOM TESTING LIBRARY" which has a lot
        of other testing Libraries📚 for other
        frameworks like angular, Vue, etc.

        ❗If you are using create-react-app
        this library📚 is already integrated,
        but since we are created our app from 
        scratch using parcel📦, we'll need 
        to integrate it ourselves.

        ❗React Testing Library uses Jest🃏
        which is a JS🟨 TESTING framework
        Jest🃏 Is a standard to write test
        cases💼.

        🔸Process we will complete:
            1. Install REACT TESTING LIBRARY🧪📚-
            2. Install Jest🃏
            3. Install Babel🦜 Dependencies⛓️
               to work with Jest🃏
            4. Configure Babel🦜 .config file
               to run with Jest🃏
            5. Configure Parcel📦 config file
               to disable default Babel🦜
               transpilation. 
            6. Jest🃏 configuration🏗️
            7. Install jsdom📑 library📚
            6. Install @babel/preset-react to
                make JSX🦐  work in test cases
            7. Include @babel/preset-react inside
            my Babel🦜 config🏗️
            8. Install @testing-library/jest-dom
            so we can use functions

    
            · Let's install REACT testing Library:

                //🖥️inside the terminal:
                > npm install --save-dev @testing-library/react

            · Now let's install Jest🃏. According with the
            documentation, to use Babel🦜 we will need 
            to install additional Dependencies⛓️:

                //🖥️inside the terminal:
                //For instaling Jest🃏 ⬇️
                > npm install --save-dev @testing-library/react

                //Babel🦜 Dependencies⛓️⬇️
                > npm install --save-dev babel-jest
                 @babel/core @babel/preset-env


            · We will also need to configure🏗️ Babel🦜 to 
            target your current version of node by 
            creating a babel.config.js file in the root 
            level of your Project let's create a new file
            named babel.config.js

                //🖥️inside babel.config.js
                module.exports = {
                presets: [['@babel/preset-env', {
                    targets: {node: 'current'}}]],
                };

        ❗Remember that Parcel📦 has already
        Babel🦜 built in, so these Dependencies⛓️
        we just installed will interfere with 
        parcel's📦 so we are trying to configure🏗️
        Babel🦜 according to us.

        It will be a conflict between the 2 
        configurations🏗️ so the one we just did 
        will try to override the existing Babel🦜
        configurations🏗️ parcel📦 had set for us. 

        So we will need to change Parcel's 📦
        behavior to acommodate and use Babel🦜
        along with Jest🃏.

        🤔But what are those changes? 
        According to Parcel's📦 documentation,
        you can make parcel📦 ignore your Babel config.
        To disable Babel transpilation in
        Parcel, override the default parcel config
        for Javascript to exclude 
        `@parcel/transformer-babel.` inside 
        a `.parcelrc` file

        This will allow other tools to continue using
        your babel config, but disable Babel🦜 transpilation
        in parcel📦. For this you need to create a new file
        called .parcelrc

                //🖥️inside .parcelrc
                    {
                    "extends": "@parcel/config-default",
                    "transformers": {
                        "*.{js,mjs,jsx,cjs,ts,tsx}": [
                        "@parcel/transformer-js",
                        "@parcel/transformer-react-refresh-wrap"
                        ]
                    }
                    }
        Now the Babel.js will not conflict with
        our previous config, the one we just wrote 
        will be the config🏗️ will be using!!!!!!

        We now have configured our Project to write
        test-cases💼.

        ·But before we can write test-cases, we need to 
        write the Jest🃏 configuration🏗️
        


🟢-----Running Jest🃏-----•·  

🤔How do we run test🧪 cases💼?
Similar with how we run our application with npm
start, we will run our tests with a command 
inside our pakage.json🎊 file called "test".

            //🖥️inside pur terminal:
            > npm run test

        Since we haven't written ANY
        test🧪 cases💼, it will say 
        `No tests found,` but that means
        we have succesfully configured
        our 
            -React Testing🧪Library,
            -Jest🃏, 
            -Babel🦜, 
            -Parcel📦

        Yaaay😊
    But before we can start writing test cases💼
    we'll need to configure🏗️ Jest🃏

                //🖥️inside the terminal:
                > npx jest --init

                //It will give us some questions to 
                create a suitable config for our project:

                -We will not be using Typescript for the 
                 configuration🏗️ file✖️
                - we will be using jsdom📑 for the 
                 Testing🧪 enviroment☑️

                    ·jsdom📑:
                     WHEN YOU WRITE CASES There's node
                     server, no browser, so we need an
                     enviroment🌱 for our project.
                     To create an enviroment🌱 we'll use
                     jsdom📑.
                     jsdom📑 is a library which parses 
                     and interacts with assembled 
                     HTML just like a browser.

                - we will choose for Jest🃏 to add 
                  coverage reports☑️
                -The provider for coverage will be 
                Babel🦜☑️
                -We will automattically clear mock calls
                , instances, contexts and results before
                every test ☑️

    Now we have created our jest.config.js file according
    with the options we chose for our configuration🏗️.

    Next, let's install our jsdom📑 library📚. According
    with the documentation of Testing🧪Library, if we
    are using Jest🃏 28 or later, `jest-enviroment-jsdom`
    package now must be installed separatedly.

                //🖥️inside the terminal:
                > npm install --save-dev jest-environment-jsdom

    We will need to install more Libraries📚 in the future.


⭐-------------------------------- Unit ⏺️ Testing🧪--------------------------------⭐

🟢-----Writing test🧪 cases💼-----•·

Let's write simple w test, some Javascript🟨 test.
For that, let's create a new component🧩, that will help us
to understand tesing. we will call it sum.js

                //🖥️inside sum.js
                export const sum = (a, b) =>{
                    return a + b
                }

    🤔But how do we write test🧪 cases💼 for
    this component?
    If we write `npm run test` in the terminal,
    it says `No tests found`, Jest🃏 was looking
    in all our files for test🧪 cases💼 and
    did not find any. But where is it searching?
    in the terminal you will find the answer in:

            //🖥️terminal returned:
             `testMatch: 👉**/__tests__/**/*.[jt]s?(x), **/?(
              *.)+(spec|test).[tj]s?(x) - 0 matches`

    Jest🃏 was looking for that⬆️ folder.
    These files are present in a folder 
    that needs to be called `__test__`.

    Now, whatever files are present inside the our
    folder named __test__📁, it will track them.
    Now, like we saw, our testMatch has a configuration🏗️
    for file extensions of .jt, jsx, or js. 

            //🖥️terminal returned:
                testMatch: **/__tests__/**/👉*.[jt]s?(x), **/?(
                *.)+(spec|test).[tj]s?(x) - 0 matches`

    So any file you create, anywhere inside the folder
    structure, if is .js or jsx, it will be 
    considered a test🧪 file

    otherwhise, if you can create a test🧪 folder called
    .test.js or .test.ts, etc
    For example you can create Header.test.js as a test 
    file or you can also use

        · Headers.test.ts
        · Headers.spec.js
        · Headers.spect.js

    All those files will be considered testing files

        🤔But what is that `__` business?
        that is syntax for dunder method of
        python, and we use it as a keyword,
        it's a convrnyion. for tests🧪, a
        reserved word for tracking testing files.

🟢-----creating our first Javascript🟨 test🧪 file-----•·

    Let's create our first test🧪 file inside our __test__📁
    folder to test our sum.js component🧩. called sum.test.js

    🤔How are we going to test our sum function?

        •FIRST of all, we use a function📽️ `test`
        that takes 2 arguments, a string and a callback
        function. The string will describe the purpose of
        the function we are testing, and inside the brackets 
        of the function it will be the test. This is the rest

                //🖥️inside sum.test.js
                import { sum } from "../sum"

                    👉test("sum function should sum of two numbers", ()=>{

                        //first we will call the function we want to test:
                        👉const result = sum(3,4)//using some parameters

                        //this line is known as ASSERTION🫡:
                        👉expect(result).toBe(7)
                        
                        //the result has to be the same as the toBe method
                    })


        now we can run the test using `npm run test` in the terminal 
        and it will tell us that our test passed!

                //🖥️terminal returned:
                    ...
                    Test Suites: 1 passed, 1 total
                    Tests:       1 passed, 1 total
                    ...

        ❗Most of the time, you will
        always have ASSERTIONs🫡 in your test, if you don't write
        an ASSERTION🫡, it will always pass no matter what.


    🟢-----creating our first REACT⚛️ test🧪 file-----•·

    We will be writing unit testing.
    First of all, let's run our app in a different terminal than our Testing🧪
    one. using `npm run start`.
    Let's create a basic test🧪 to see if our component🧩 is loaded or not. 

    We'll be using our Contact.js component🧩
    we'll try to render it, and see if it loads or not.
    But first let's fill a little bit our component🧩, since 
    it's looking quite empty.

                    //🖥️inside .parcelrc
                    const Contact = () => {
                        return (
                            <div>
                                <h1>Contact us page</h1>
                                <form>
                                <input type="text"
                                placeholder="name" />

                                <input type="text"
                                placeholder="message" />

                                <button>Submit</button>
                                </form>
                            </div>
                        );
                    }
                    export default Contact;


        • Now is time to write the test, inside a new
        component🧩 inside our __test__📁 folder we
        will call `Contact.test.js`:

                    //🖥️inside .parcelrc

                    import { render, screen } from "@testing-library/react"
                        import Contact from "../Contact"

                        test(
                            "should load contact.js component", () => {

                            👉render(<Contact />)//this wil render it to 
                            the js DOM

                            /*Now we will test it if it was successfully 
                            rendered:
                            For that we will use the screen() method
                            screen is an obj that comes from the 
                            testing library
                            that give us access to the component elements*/

                            /*Thanks to the screen obj, we can use the 
                            getbyRole
                            method to find all the elements with a 
                            given role value: */

                            👉const heading = screen.getByRole("heading")

                            /*Now that we got our element, we can expect some results
                            by manipulating it */

                            👉expect(heading).toBeInTheDocument()
                        })

        🤔However, this test has failed, but why?
        in the terminal it shows `Support for the experimental syntax '
        jsx' isn't currently enabled`

        so JSX🦐 is not enabled for our app!

        🤔How can we enable JSX🦐??
        in the terminal it shows ` Add @babel/preset-react `, So Jest🃏
        is helping us to solve this issue

                    //🖥️inside the terminal:
                    //For enabling JSX🦐 ⬇️

                    >npm i -d @babel/preset-react

        And we will need to Include @babel/preset-react 
        inside  my Babel🦜 config🏗️:

                    //🖥️inside babel.config.js :
                    module.exports = {
                    presets: [['@babel/preset-env', {
                        targets: { node: 'current' } }]
                        
                        /*it will automatically pick the runtime,
                            If we don't add the runtime thing, wit will
                            pick an error: ⬇️*/

                            👉["@babel/preset-react", { 
                                runtime: "automatic" }]
                        
                        ],
                    };

        🤔Why do we need this preset??
        basically, Babel🦜 is a transpiler. Right 
        now this Babel preset in react is helping
        the Testing🧪Library📚 to convert the JSX🦐
        code to XTML/html so it can read it properly

        But it continues to fail 😭, why????
        in the terminal says `TypeError: expect(...
        ).toBeInTheDocument is not a function`

        This is because we haven't installed the 
        library📚 for toBeInTheDocument().
        This library📚 is jest-dom


                    //🖥️inside the terminal:
                    npm i -D @testing-library/jest-dom

        when is fixed, we can import the library to our test🧪
        file:
                    //🖥️inside Contact.test.js:
                    import "@testing-library/jest-dom";

        Once the library📚 is included, as soon as you
        write anu ASSERTION🫡, (an expect statement)
        vscode suggest you a lit of methods that we can
        use to test🧪 our selected element.

        This time the test🧪 passed✅

        • Let's make a render test🧪 for our Submit button🔘.

                    //🖥️inside Contact.test.js:
                    test("should load button inside contact.js component", () => {

                    render(<Contact />)//this wil render it to the js DOM

                    const button = screen.getByRole("button")

                        expect(button).toBeInTheDocument();
                    })

        · So with this line:
        `const heading = screen.getByRole("heading")`
        the getByRole method can help you with every kind of role in the html
        this roles are defined by Jest🃏 inside the Testing🧪Library📚
        there's more ways to access our button, we can also use

            - screen.getByText("Submit")
                this will look for matches of text in our screen 
                object and find our `Submit` button🔘

        If you try to find a non-existent eleement, the test🧪 wil fail

        The beauty of Jest🃏 is that, whenever it fails, the test, it 
        will show you what was rendered so you can see it for reference

        • Let's make a render test🧪 for our placeholder text inside our
        input attribute:

                    //🖥️inside Contact.test.js:
                    test("should load the name input inside contact.js component", () => {

                        render(<Contact />)//this wil render it to the js DOM

                        const input = screen.getByPlaceholderText("name")

                        expect(input).toBeInTheDocument();
                    })

        • What we would do if we wanted to get Multiple the input attributes:

                    //🖥️inside Contact.test.js:
                    test("should load 2 input boxes inside contact.js component", () => {

                        render(<Contact />)

                        //there's not role named "input", the appropiate term is "textbox:"
                    👉 const inputBoxes = screen.getByRole("textbox")


                        expect(inputBoxes).toBeInTheDocument();
                    })
        
                ❗However, this will throw an error saying there are multiple elements 
                with the role "textbox" 😱 why??
                because the appropiate method to check ALL the elements with the same 
                role is getAllByRole().
                Let's use it and log into the console what do we get using this method:

                    //🖥️inside Contact.test.js:
                    test("should load 2 input boxes inside contact.js component", () => {

                        render(<Contact />)

                        //This is known as querying🙋‍♀️ the getByAll()
                        const inputBoxes = screen.getAllByRole("textbox")

                        //intputBoxes will be an array of objects
                        //here we log the first element of the array:
                        console.log(inputBoxes[0])
                    })

                We get a react element with all its properties. Remember that at the
                end of the day JSX🦐 is a way to write REACT⚛️ elements and 
                REACT⚛️ elements are OBJECTS!

                If we are querying🙋‍♀️ we do something like screen. and add a get
                method and make things return to us!

                Now let's check with our ASSERTION🫡 if we actually have 2 input
                boxes:

                    //🖥️inside Contact.test.js:
                    test("should load 2 input boxes inside contact.js component", () => {

                    render(<Contact />)

                    const inputBoxes = screen.getAllByRole("textbox")

                    //since our inputBoxes is an array of objects:
                    👉expect(inputBoxes.length).toBe(2)
                })

                · We can also check a FALSE amount using the `not` keyword:
                - expect(inputBoxes.length).not.toBe(3)
        
    These were only the basics of Testing🧪, some important things:

    🚨Remember: when Testing🧪 you will allways need to

        1️⃣ RENDER🖌️ something
        2️⃣ QUERY🙋‍♀️ something
        3️⃣ ASSERT🫡 something

    🚨Remember that `test()` is the name of the function, you can 
    also use `it` like this: 

                //🖥️inside Contact.test.js:
                    👉it("should load 2 input boxes inside contact.js component", () => {
                    ...
                })

        There's no Difference!!!!!! it() is just an alias of test()

    🚨Remember to hover over the methods in VSCODE if you don't understand any,
    it will typically provide explanations on how the code works

🟢-----Managing Multiple test🧪 cases💼 USING describe🖋️-----•·

    We have now written several test🧪 cases💼
    Sometimes the number of tests🧪 becomes unmanageable,
    in that circumstance, we can put them in group, 
    that means, puting all the test🧪 cases💼 inside
    a block code  named describe🖋️.

    Let's use describe🖋️ to contain all our Contact.js
    test🧪 cases:

                //🖥️inside Contact.test.js:
                describe("Contact us Page test cases", () => {

                test("should load contact.js component", () => {...})

                test("should load the name input inside contact.js component", () => {...})

                test("should load 2 input boxes inside contact.js component", () => {...})

                });


        🚨Everything works the same, this is just for grouping tests🧪

        ❕you can also nest🪺 one describe🖋️ in another describe🖋️
        ❕You can have multiple describe🖋️ in a single file
        ❕



🟢-----Coverage📁-----•·

As we can see inside our projects,t there are many more files
than before. This is because our Coverage📁 and the new files
it contains, it was added with Jest🃏 in order to have the 
capacity to cover all our files in our Testing🧪

This file is inside our Dependencies⛓️ so is not necessesary
to push it to our Git🐈‍⬛ repository, so we can put it inside
our `.gitignore` file:


                //🖥️inside Contact.test.js:
                /node_modules/
                /dist/
                /.parcel-cache/
                👉/coverage/


🟢-----Testing🧪 our Header component🧩-----•·

    🚨Remember that we are making Unit Testing🧪, now we are going to test
    our header component🧩 to see if:

        - It loads the Login🔐 button🔘
        - our Cart🛒 element starts with 0 elements inside

    so to start, we create a new testing file called Header.test.js

                //🖥️inside Header.test.js:
                describe("Contact us Page test cases", () => {
    
                    it("Should load Header Component with a 
                    login button", ()=>{
                        render(
                            <Header/>
                        )
                    })
                })

    ❗However, this throws an ERROR, that is because our Cart🛒
    functions with Redux, so we will have to provide Redux to our
    component🧩 using <Provider> and provide our appStore
    so it has access to our Redux code

                //🖥️inside Header.test.js:
                describe("Contact us Page test cases", () => {
    
                    it("Should load Header Component with a 
                    login button", ()=>{
                        render(
                            <Provider store={appStore}>
                            <Header />
                            </Provider>
                        )
                    })
                })


    ❗This throws an ERROR, because the Link element is not
    supported by Jest🃏, since we got it from ROUTER🛣️ we will need to wrap
    our test🧪 inside that feature:


                //🖥️inside Header.test.js:
                    import { render } from "@testing-library/react";
                    import { Provider } from "react-redux";
                    import appStore from "../../../utils/redux/appStore.js";
                    import Header from "../Header";
                    import { BrowserRouter } from "react-router-dom";

                    it("Should load Header Component with a login button", () => {
                        render(
                            <BrowserRouter>
                                <Provider store={appStore}>
                                    <Header />
                                </Provider>
                            </BrowserRouter>
                        );
                    });
                        

    Now that we can RENDER🖌️ Properly, is time to QUERY🙋‍♀️ and ASSERT🫡:


                      //🖥️inside Header.test.js:
                   ...
                    it("Should load Header Component with a login button", () => {
                        render(
                            <BrowserRouter>
                                <Provider store={appStore}>
                                    <Header />
                                </Provider>
                            </BrowserRouter>
                        );
                        👉const  login = screen.getByRole("button")
                        //const loginButton = screen.getByText("Login") ⬅️is also correct
                        //but you should use Role

                        👉expect(login).toBeInTheDocument();
                    });
    
    If there are multiple buttons and you only need the Login🔐 one, this is a
    way to single it out:

                          //🖥️inside Header.test.js:
                            ...
                            it("Should load Header Component with a login button", () => {
                                render(
                                ...
                                );
                                👉const  login = screen.getByRole("button", {name: "Login"})

                                expect(login).toBeInTheDocument();
                            });


    • Cart🛒 Test🧪 case💼:

    Let us find out if the Cart🛒 component🧩 start empty: 
    

                              //🖥️inside Header.test.js:
                            ...
                            it("Should load Header Component with no cart items", () => {
                            render(
                                <BrowserRouter>
                                    <Provider store={appStore}>
                                        <Header />
                                    </Provider>
                                </BrowserRouter>
                            );

                            👉const  cartItems = screen.getByText("🛒 (0 items)")

                            👉expect(cartItems).toBeInTheDocument();
                        });

    - But what if we want to check if there's a Cart🛒 component🧩? in that case we can use
    a regex to match part of the text without exactly getting it, like this

                                  //🖥️inside Header.test.js:
                            ...
                            it("Should load Cart Component inside Header", () => {
                            render(
                                <BrowserRouter>
                                    <Provider store={appStore}>
                                        <Header />
                                    </Provider>
                                </BrowserRouter>
                            );

                            👉const  cart = screen.getByText(/🛒/)

                            expect(cart).toBeInTheDocument();
                        });

    • Login🔐 text change Test🧪 case💼:

        Our app changes the Login text everytime we click, on it, let's test🧪 this feature:

                             //🖥️inside Header.test.js:
                                  ...
                                    it("Should change Login button to Logout on Click", () => {
                                render(...);
                                    //Getting the Login🔐 button
                                👉const loginButton = screen.getByRole("button", {name: "Login"});

                                    //we can use fireEvent this to check on Events
                                    //first we need to import it from "@testing-library/react"
                                    //syntax: fireEvent.eventThatWillFire(place where my event should fire):
                                👉fireEvent.click(loginButton)

                                    //Now let's access the logout button that we changed to:

                                    👉const logoutButton = screen.getByRole("button", {name: "Logout"});

                                    /*If the event was fired succesfully, we will expect the  Logout
                                    Button to be in the document:*/
                                    
                                👉expect(logoutButton).toBeInTheDocument();
                            });

🟢-----Testing🧪 our Restaurant Card component🧩 -----•·

    Let's check if we can test our RestaurantCard component🧩 considering that
    props are being passed inside:

    for that we will create MockData🎭 to pass it like props, and see if it's working

    that MockData🎭 will be in a separate folder called mocks📁
    inside we will make a file to test our RestaurantCard component🧩, "resCardMock.json"
    that will contain an object similar to the ones that are inside of the array of
    the restaurant menu array:



                             //🖥️inside Header.test.js:
                                {
                                    "id": "71579",
                                    "name": "Hotel Inayat Cafe",
                                    "avgRating": 4.2,
                                    "cuisines": [
                                    "North Indian",
                                    "Biryani",
                                    "Chinese"
                                    ],
                                    "promoted": true,
                                    "sla": {
                                    "deliveryTime": 25,
                                    "lastMileTravel": 2.3,
                                    "serviceability": "SERVICEABLE",
                                    "slaString": "25 mins",
                                    "lastMileTravelString": "2.3 km",
                                    "iconType": "ICON_TYPE_EMPTY"
                                    },
                                    "cloudinaryImageId": "jvuhbo6nvyt8tsiwkll6"
                                }

    We will RENDER🖌️ our Header component🧩  inside our test, and pass the MockData🎭
    as a prop. Later, we will get one of the text elements inside it to see if it was
    passed succesfully.


                             //🖥️inside Header.test.js:
                                it("Should render RestaurantCard Component with props Data", () => {

                                    render(<RestaurantCard resData={MOCK_DATA} />);

                                    console.log(screen)

                                    //checking if we can find the name property:

                                    const name =  screen.getByText("Hotel Inayat Cafe")
                                    

                                    expect(name).toBeInTheDocument(); 
                                });


    Now 



⭐--------------------------------Integration🚸 Testing🧪--------------------------------⭐

🟢-----Writing test🧪 cases💼 for Integration🚸 testing on the Body component🧩-----•·

let's test🧪 our Search🔎 feature that is inside our body component
For that we will create a test🧪 file inside our __test__📁 folder
Inside our search let's first render the whole Body.js component🧩

An important part of our Body component is making an API call.
we will later write test🧪 cases💼 for that scenario

    But firslt, let's render the whole body component🧩 and checking if my
    Search🔎 button is there, we will write the Integration🚸 test later:

                             //🖥️inside Search.test.js:
                            it(
                            "Should render RestaurantCard Component with props Data", (

                            ) => {
                            render(<Body/>)
                            })

    ❗However, this returns an ERROR❌, it fails beause "ReferenceError: fetch is not defined"
    🤔Why? when you test🧪 the Body components🧩, is not rendering it on the Browser🌐, 
    it is rendering in the Jest🃏 jsdom📑 which is obly Browser🌐-like, meaning it doesn'takes
    have ALL the browser's super powers, Fetch🐕 is a superpower in the browser, is not a native
    function of Javascript🟨, is kinda like an API inside Javascript🟨 but not native! Jest🃏
    does not understand fetch. 

    So we will need to use a mock function📽️ for our test,
    This is how we write it 

                             //🖥️inside Search.test.js:

                                /*global object that will replace the fetch function,
                                we are defining it inside a global object
                                And we will define our data as a jest function: ⬇️ */
                                    global.fetch = jest.fn(() =>{
                                        //our jest function takes a callback function:
                                        //Here we will mock how our fetch function works inside Body.js
                                        /*Our fetch function returns a promise, so we will need to 
                                        /return a promise function: */
                                        return Promise.resolve({
                                            // now it resolves the promise
                                            //and is resolved thru a json:
                                            //and json is a function that returns  another promise:
                                            json: ()=>{
                                                //this json returns also a promise that needs resolve:
                                                //and this promise actually has data that will be 
                                                //...mock data:
                                                ➡️return Promise.resolve(MOCK_DATA)
                                            }
                                        })
                                    })

    For this to work we will need to create more MockData🎭 inside a file that we will call
    mockResListData.json and import it as `MOCK_DATA`. This is how our file looks now:

                             //🖥️inside Search.test.js:
                                import { render, screen} from "@testing-library/react"
                                import MOCK_DATA from "../../mocks/mockResListData.json"
                                
                                    global.fetch = jest.fn(() =>{
                                        return Promise.resolve({
                                            json: ()=>{
                                            return Promise.resolve(MOCK_DATA)
                                            }
                                        })
                                    })
                                it("Should render Body component, () => {
                                    render(<Body/>)
                                    })`

        And the test passed✅ but with a warning⚠️, which tell us that every time 
        we make an async operation or doing a state☁️ we need to write our RENDER🖌️
        method wrapped in an act function.
        This is the warning⚠️:

             `Warning: An update to Body inside a test was not wrapped in act(...).
                When testing, code that causes React state updates should be wrapped into act(...):
                act(() => {
                    /* fire events that update state */
                });`

        🚨 This act()👩🏻‍🎤 function is coming from `react-dom/test-utils`, and we need to 
        import it from there.

                             //🖥️inside Search.test.js:
                                ...
                                import { act } from "react-dom/test-utils"
                                
                                    global.fetch = jest.fn(() =>{
                                        ...
                                    })
                                it("Should render RestaurantCard Component with props Data", async () => {
                                //we need to render our react elements inside an act() function,
                                //the act() function will return a promise:
                                //Since we return a promise, we'll need to use await.
                                //since we use await, we need to use async

                                👉await act( async ()=> { render(<Body/>)});

                                // an act function returns a callback that is also async⬆️
                                //and will render our component.
                            })

                However, this will throw an ERROR❌: 
                `The above error occurred in the <Link> component:`
                we already know how to solve this issue, we just wrap our component🧩
                inside our BrowserRouter

                             //🖥️inside Search.test.js:
                                ...
                                import { BrowserRouter } from "react-router-dom";
                                
                                    global.fetch = jest.fn(() =>{...})
                                it("Should render Body component, () => {
                                    await act( async ()=> { render(
                                        <BrowserRouter>
                                        <Body/>
                                        </BrowserRouter>
                                    )});
                                    })`


                Now our test🧪 passed✅, We have rendered our component🧩 succesfully, it's
                time to QUERY🙋‍♀️ and  ASSERT🫡 our Search🔎 button:

                             //🖥️inside Search.test.js:
                                ...
                                it("Should render search button", async(

                                ) => {
                                    await act( async ()=> { render(
                                        <BrowserRouter>
                                        <Body/>
                                        </BrowserRouter>
                                    )});

                                    const searchBtn =  screen.getByRole("button", {name: "Search"})

                                    expect(searchBtn).toBeInTheDocument();
                                })

        • Tip: 
        💡To avoid runing the tests🧪 again and again using "npm run test"
        we can add a new script to our package.json🎊 file called
        "watch-test" so every time we save our project, it tests it 
        automatically:

                             //🖥️inside package.json🎊
                             {
                                ...
                                "scripts": {
                                    "start": "parcel index.html",
                                    "build": "parcel build index.html",
                                    "test": "jest",
                                    ➡️"watch-test": "jest --watch"
                                }
                                }

                -and then writing on terminal: `npm run watch-test`
                Watch Usage
                › Press a to run all tests.
                › Press f to run only failed tests.
                › Press p to filter by a filename regex pattern.
                › Press t to filter by a test name regex pattern.
                › Press q to quit watch mode.
                › Press Enter to trigger a test run.


        • Now let's make a test🧪 by writing something inside the input 
        area of the search button, using a new method called getByTestId.
        We will add a new attribute called "data-testId" which value will
        be the ID we want to give to that input element:

                             //🖥️inside Body.js
                             ...
                             <div className="search">
                            <input 
                            className="rounded-sm p-1 w-60"
                                type="text" 
                                👉data-testid = "searchInput"
                                placeholder="Type a meal..."
                                value={searchText}
                                onChange={(e) => {
                                    setsearchText(e.target.value)
                                }}
                            />
                             ...

        Now we access the input element through our data-testid

                             //🖥️inside Search.test.js:
                             it("Should render input box text", async () => {
                                await act( async ()=> { render(
                                    <BrowserRouter>
                                    <Body/>
                                    </BrowserRouter>
                                )});

                                const searchInput =  screen.getByTestId(searchInput)
                            });


        It's time to type something in our test🧪 to see if it works, but 🤔How
        can we do that? we will need to trigger an event using fireEvent(), and
        inside, simulate changing the value inside the input box like we made
        inside our Body component🧩 using e.target.value

                             //🖥️inside Search.test.js:

                             it("Should search Res list for pizza using text imput", async () => {
                                await act( async ()=> { render(
                                    ...
                                )});

                                const searchInput =  screen.getByTestId("searchInput")

                                //fireEvent will recieve our searchInput
                                //and pass an object that will simulate what we get 
                                //inside the event.
                                👉fireEvent.change(searchInput, {target: {value: "pizza"}});
                            });

        Now let's simulate clicking the Search🔎 button to actually test🧪 our 
        functionality. For that we will need to use fireEvent() and get our button
        clicked. After that, according to our data, we can expect 2 cards to
        appear inside our body component🧩.

        🤔How can we check on that? well, at the end of the day, each Card is
        a <div> element.
        🤔How can we access it inside my test?
        We can use testId in order to count them.


                            //🖥️inside RestaurantCard.JS🟨
                                ...
                                const RestaurantCard = (props) => {
                                ...
                                    
                                    return (
                                        <div 
                                        👉data-testid = "resCard"
                                        ...
                                        </div>
                                    );
                                }

        Now, with getAllByTestId() we can get all the cards on the screen📺, 
        using the TestId attribute. since we have only 2 "pizza" related cards, 
        The length of the array returned by getAllByTestId()  should equal 2


                            //🖥️inside Search.test.js
                            it("Should search Res list for pizza using text imput", async () => {
                            await act( async ()=> { render(
                                ...
                            )});

                            const searchBtn =  screen.getByRole("button", {name: "Search"})
                            const searchInput =  screen.getByTestId("searchInput")

                            fireEvent.change(searchInput, {target: {value: "pizza"}});
                            fireEvent.click(searchBtn)

                            //ASSERT: Screen should load 2 cards: 
                            👉const cards  =  screen.getAllByTestId("resCard")

                            👉expect(cards.length).toBe(2)
                        });


            It passed✅!

        Just to have our test🧪 more rounded, let's check if it's delivering the 
        correct amount of cards that we want to display inside our Body component🧩.
        In this case, they are 20 in total. So before our click event we add:

                        //🖥️inside Search.test.js
                            it("Should search Res list for pizza using text imput", async () => {
                            await act( async ()=> { render(
                                ...
                            )});

                            const searchBtn =  screen.getByRole("button", {name: "Search"})
                            const searchInput =  screen.getByTestId("searchInput")

                            👉const cardsBeforeSearch = screen.getAllByTestId("resCard")
                            👉expect(cardsBeforeSearch.length).toBe(20)

                            fireEvent.change(searchInput, {target: {value: "pizza"}});
                            fireEvent.click(searchBtn)

                            const cardsAfterSearch   =  screen.getAllByTestId("resCard")

                            expect(cardsAfterSearch.length).toBe(2)
                        });

            Once again, our tests passed✅!

        • Let's test one last feature, our Top Restaurants button, to see if it filters
        the top restaurants:

                        //🖥️inside Search.test.js
                            it("Should filter the top rated restaurants", async()=>{
                            await act(async ()=>{
                            render(
                                <BrowserRouter>
                                <Body/>
                                </BrowserRouter>
                            )});

                            //let's check our  number of cards before filtering⬇️:
                            const cardsBeforeFilter = screen.getAllByTestId("resCard")
                            expect(cardsBeforeFilter.length).toBe(20)

                            //finding the button and clicking it⬇️:
                            const topRatedBtn = screen.getByRole("button", {name: "Top Rated Restaurants"})
                            fireEvent.click(topRatedBtn)

                            const cardsAfterFilter = screen.getAllByTestId("resCard")

                            //getting the filtered cards⬇️:
                            expect(cardsAfterFilter.length).toBe(10)
                    })

            Once again, our tests passed✅!


🟢-----beforeAll(), beforeEach(), afterAll(), afterEach()-----•·

    Helper functions📽️ that can help us to manage tests🧪: 

    · beforeAll(). Suppose that you have a describe(...) block of tests,
    and you will like to perform some action ONCE, before all of them start
    to execute. You can use the beforeAll() function inside the block
    and on the top of all tests🧪.
    It takes a callback function, and whatever you want to pass inside
    the callback it will execute.

    · beforeEach() works the same, except it will execute before EACH test,
    one time for each of the tests. So it's very helpful if we have to 
    do some cleanup task

    · afterAll() : similarly to beforeAll(), this function📽️ executes 
    once after ALL the test have been executed 

    · afterEach() like beforeEach() it executes one time for each test
    after it has been executed 


                //🖥️inside Contact.test.js:
                describe("Contact us Page test cases", () => {

                    //Will run the function Before ALL the tests🧪
                    👉beforeAll(()=>{
                        console.log("Before All")
                    });

                    👉beforeEach(()=>{
                        console.log("Before each")
                    })


                test("should load contact.js component", () => {...})

                test("should load the name input inside contact.js component", () => {...})

                test("should load 2 input boxes inside contact.js component", () => {...})

                });
🟢-----Writing test🧪 cases💼 for Integration🚸, Cart🛒 component🧩-----•·

    Let's test a very important functionality inside our app, our Cart🛒 component🧩.
    And if we are able to add things to our Cart🛒.

    We'll start by creating a new test🧪 file called `Cart.test.js`
    then we'll create mock data for a restaurant in a file called `resCardMock.json"

    and Fetch🐕 The MockData🎭 using the act() function📽️, rendering wraping our
    component🧩 inside our BrowserRouter.

    Inside this test file, we will mock rendering a Restaurant Menu, clicking 
    an item inside one of the menu sections, and adding it to the cart, let's
    start by just RENDER🖌️ the Restaurant Menu using a mock data file that
    we will call `mockResMenu.js`, we will import it using a fetch function of
    our own, like we did before with Search🔎


                //🖥️inside Cart.test.js:

                    import MOCK_DATA_MENU from "../../mocks/mockResMenu.json";

                    global.fetch = jest.fn(()=>
                    Promise.resolve({
                        json: () => Promise.resolve(MOCK_DATA_MENU)
                    })
                    );

            Now is time to RENDER🖌️ our RestaurantMenu component🧩.
            Just like before, we will need to wrap it inside an 
            act() function that will be async.
            Inside it we will need to Provide the Redux appstore that
            makes our cart work, otherwise it will throw an ERROR❌
            and also, we need to wrap it inside our BrowserRouter for our
            Links to work:


                //🖥️inside Cart.test.js:
                 ...
                    it("should Load Restaurant Menu Component", 
                    async () => {
                        await act(async () =>
                        render(
                            <BrowserRouter>
                            <Provider store={appStore}>
                                <RestaurantMenu />
                            </Provider>
                            </BrowserRouter>
                        )
                        );

                    });

            Let's do a couple of things:
            1️⃣ simulate that we are clicking the "Extras"
            category inside our accordion that is inside
            our Menu
            2️⃣Clicking our accordion header to open it

                //🖥️inside Cart.test.js:
                 ...
                    it("should Load Restaurant Menu Component", 
                    async()=>{
                    await act(...)
                        //querying🙋‍♀️ the menu:
                    1️⃣const accordionHeader = screen.getByText(
                        "Extras (4)")
                    2️⃣fireEvent.click(accordionHeader);
                    });

        Now we want to get ALL the items that are inside our
        `Extras` we can get them all assigning TestId for
        each item of our list, inside of our ItemList component.
        our TestId will be "foodItems". For this category, we 
        should have an array of 4 foodItems

                        //🖥️inside Cart.test.js:
                 ...
                    it("should Load Restaurant Menu Component", 
                    async()=>{
                    await act(...)
                    ...
                    const foodItems = screen.getAllByTestId(
                        "foodItems")
                    expect(foodItems.length).toBe(4)
                    });

        The next thing we will need to do is to simulate clicking
        the first add➕ button of our food items
        and check if our Cart🛒 component🧩 inside our Header, 
        component🧩,
        where it counts the items that have been added to our Cart,
        has updated

         //🖥️inside Cart.test.js:
                 ...
                   it("should Load Restaurant Menu Component", async () => {
                    await act(async () =>
                    //Importing our header:
                    render(
                        <BrowserRouter>
                        <Provider store={appStore}>
                            <RestaurantMenu />
                           👉 <Header/>
                        </Provider>
                        </BrowserRouter>
                    )
                    );
                    ...
                    //Getting the add➕ buttons:
                    👉const addBtns =  screen.getAllByRole("button", {name: "Add +"})

                    //Clicking the first add➕ button of our array:
                   👉 fireEvent.click(addBtns[0])

                   //Checking if the Header has been updated:
                    👉expect(screen.getByText("🛒 (1 items)")).toBeInTheDocument()
                });

        Tip🚨
        💡Always create separate tests, instead of puting them all inside
        a single one like we did here💡


                //🖥️inside Cart.test.js:
                    it("should render Cart component with 2 items", async () => {
                    await act(async () =>
                    render(
                        <BrowserRouter>
                        <Provider store={appStore}>
                            👉<Cart/>
                            <RestaurantMenu />
                            <Header/>
                        </Provider>
                        </BrowserRouter>
                    )
                    );

                    const accordionHeader = screen.getByText("Extras (4)")

                    fireEvent.click(accordionHeader)

                    const addBtns =  screen.getAllByRole("button", {name: "Add +"})

                    fireEvent.click(addBtns[0])

                    fireEvent.click(addBtns[1])

                    /* Counting our foodItems including the ones in the 
                    Restaurant Menu(4), 
                    header(2)
                    and the cart component(2)*/
                    👉expect(screen.getAllByTestId("foodItems").length).toBe(8);

                    //checking our "Clear Cart button"
                    👉fireEvent.click(screen.getByRole("button", {name : "Clear Cart"}))
                    //Now only RestaurantMenu is rendering the 4 foodItems insde `Extras`
                    👉expect(screen.getAllByTestId("foodItems").length).toBe(4);
                    //checking if cart component is empty:
                    👉expect(screen.getByText("Cart is empty")).toBeInTheDocument()

                    })

🟢-----Checking our Coverage📁

Inside our terminal we can see that our tests have a coverage
of 94% inside our app, to check where some coverage is missing,
we can look at the Coverage📁 folder, then go to 
Icov-report > index.html and open with
