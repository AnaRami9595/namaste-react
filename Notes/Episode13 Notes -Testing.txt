ğŸŸ¢-----Developer TestingğŸ§ª-----â€¢Â·

Here we are going to talk about different ways
to test our application. 

    â€¢ Manual testingğŸ‘ŒğŸ½:
        the practice of checking if your code 
        works and the features are functional.
        this is not very efficient, because if\
        you change the code a little you will 
        need to get back and chec if works.

        Whenever we add a line ri our code, 
        that can introduce bugs in our app
        ANYWHERE. This is specially complicated
        if your'e building a large scale app.

        That's why TestingğŸ§ª is very important

    â€¢  Test CodeâŒ¨ï¸
        Writing test casesğŸ’¼ to prove our app
        works. It will test our application
        automatically, this is what we are 
        going to do today.

            Types of DEVğŸ¤“ caseğŸ’¼ TestingğŸ§ª:

                Â· Unit âºï¸TestingğŸ§ª
                Â· IntegrationğŸš¸ TestingğŸ§ª
                Â· End to EndğŸ”š testing (e2e)

    
ğŸŸ¢-----TYPES of DEVğŸ¤“ TestingğŸ§ª-----â€¢Â·

    â€¢ Unit âºï¸TestingğŸ§ª
      You test your REACTâš›ï¸ components in 
      isolation. If you want to test the 
      header componentğŸ§©, you will try To
      render your header componentğŸ§© in
      isolation to the rest of the app.
      
    â€¢ IntegrationğŸš¸ TestingğŸ§ª
      TestingğŸ§ª the IntegrationğŸš¸ between
      the componentsğŸ§©, all of them are 
      colaborating to make a feature, 
      you will develop a flow of their 
      colaboration, how are they talking to 
      each other  

    â€¢ End to EndğŸ”š testing (e2e)
      It means testing a REACTâš›ï¸ app as 
      soon as the user enters the react
      application until he leaves it,
      checking all the flows. Starts
      on the landing and how the user
      will flow across the app. 
    
    EndğŸ”š to EndğŸ”š testing requires
    different kind of ToolsğŸ”¨, so will be
    only concerned with the first two. 



    ğŸ”¹ğŸ’¡Interview questionğŸ’¡
        TestingğŸ§ª is now considered as part of 
        the developer job. Testing is part of 
        writing code. Make this a habit.

    
ğŸŸ¢-----REACT TESTING LIBRARYğŸ§ªğŸ“š-----â€¢Â·  

        â€¢ is the most common way of testing
        REACTâš›ï¸ code. It is build on top of
        "DOM TESTING LIBRARY" which has a lot
        of other testing LibrariesğŸ“š for other
        frameworks like angular, Vue, etc.

        â—If you are using create-react-app
        this libraryğŸ“š is already integrated,
        but since we are created our app from 
        scratch using parcelğŸ“¦, we'll need 
        to integrate it ourselves.

        â—React Testing Library uses JestğŸƒ
        which is a JSğŸŸ¨ TESTING framework
        JestğŸƒ Is a standard to write test
        casesğŸ’¼.

        ğŸ”¸Process we will complete:
            1. Install REACT TESTING LIBRARYğŸ§ªğŸ“š-
            2. Install JestğŸƒ
            3. Install BabelğŸ¦œ Dependenciesâ›“ï¸
               to work with JestğŸƒ
            4. Configure BabelğŸ¦œ .config file
               to run with JestğŸƒ
            5. Configure ParcelğŸ“¦ config file
               to disable default BabelğŸ¦œ
               transpilation. 
            6. JestğŸƒ configurationğŸ—ï¸
            7. Install jsdomğŸ“‘ libraryğŸ“š
            6. Install @babel/preset-react to
                make JSXğŸ¦  work in test cases
            7. Include @babel/preset-react inside
            my BabelğŸ¦œ configğŸ—ï¸
            8. Install @testing-library/jest-dom
            so we can use functions

    
            Â· Let's install REACT testing Library:

                //ğŸ–¥ï¸inside the terminal:
                > npm install --save-dev @testing-library/react

            Â· Now let's install JestğŸƒ. According with the
            documentation, to use BabelğŸ¦œ we will need 
            to install additional Dependenciesâ›“ï¸:

                //ğŸ–¥ï¸inside the terminal:
                //For instaling JestğŸƒ â¬‡ï¸
                > npm install --save-dev @testing-library/react

                //BabelğŸ¦œ Dependenciesâ›“ï¸â¬‡ï¸
                > npm install --save-dev babel-jest
                 @babel/core @babel/preset-env


            Â· We will also need to configureğŸ—ï¸ BabelğŸ¦œ to 
            target your current version of node by 
            creating a babel.config.js file in the root 
            level of your Project let's create a new file
            named babel.config.js

                //ğŸ–¥ï¸inside babel.config.js
                module.exports = {
                presets: [['@babel/preset-env', {
                    targets: {node: 'current'}}]],
                };

        â—Remember that ParcelğŸ“¦ has already
        BabelğŸ¦œ built in, so these Dependenciesâ›“ï¸
        we just installed will interfere with 
        parcel'sğŸ“¦ so we are trying to configureğŸ—ï¸
        BabelğŸ¦œ according to us.

        It will be a conflict between the 2 
        configurationsğŸ—ï¸ so the one we just did 
        will try to override the existing BabelğŸ¦œ
        configurationsğŸ—ï¸ parcelğŸ“¦ had set for us. 

        So we will need to change Parcel's ğŸ“¦
        behavior to acommodate and use BabelğŸ¦œ
        along with JestğŸƒ.

        ğŸ¤”But what are those changes? 
        According to Parcel'sğŸ“¦ documentation,
        you can make parcelğŸ“¦ ignore your Babel config.
        To disable Babel transpilation in
        Parcel, override the default parcel config
        for Javascript to exclude 
        `@parcel/transformer-babel.` inside 
        a `.parcelrc` file

        This will allow other tools to continue using
        your babel config, but disable BabelğŸ¦œ transpilation
        in parcelğŸ“¦. For this you need to create a new file
        called .parcelrc

                //ğŸ–¥ï¸inside .parcelrc
                    {
                    "extends": "@parcel/config-default",
                    "transformers": {
                        "*.{js,mjs,jsx,cjs,ts,tsx}": [
                        "@parcel/transformer-js",
                        "@parcel/transformer-react-refresh-wrap"
                        ]
                    }
                    }
        Now the Babel.js will not conflict with
        our previous config, the one we just wrote 
        will be the configğŸ—ï¸ will be using!!!!!!

        We now have configured our Project to write
        test-casesğŸ’¼.

        Â·But before we can write test-cases, we need to 
        write the JestğŸƒ configurationğŸ—ï¸
        


ğŸŸ¢-----Running JestğŸƒ-----â€¢Â·  

ğŸ¤”How do we run testğŸ§ª casesğŸ’¼?
Similar with how we run our application with npm
start, we will run our tests with a command 
inside our pakage.jsonğŸŠ file called "test".

            //ğŸ–¥ï¸inside pur terminal:
            > npm run test

        Since we haven't written ANY
        testğŸ§ª casesğŸ’¼, it will say 
        `No tests found,` but that means
        we have succesfully configured
        our 
            -React TestingğŸ§ªLibrary,
            -JestğŸƒ, 
            -BabelğŸ¦œ, 
            -ParcelğŸ“¦

        YaaayğŸ˜Š
    But before we can start writing test casesğŸ’¼
    we'll need to configureğŸ—ï¸ JestğŸƒ

                //ğŸ–¥ï¸inside the terminal:
                > npx jest --init

                //It will give us some questions to 
                create a suitable config for our project:

                -We will not be using Typescript for the 
                 configurationğŸ—ï¸ fileâœ–ï¸
                - we will be using jsdomğŸ“‘ for the 
                 TestingğŸ§ª enviromentâ˜‘ï¸

                    Â·jsdomğŸ“‘:
                     WHEN YOU WRITE CASES There's node
                     server, no browser, so we need an
                     enviromentğŸŒ± for our project.
                     To create an enviromentğŸŒ± we'll use
                     jsdomğŸ“‘.
                     jsdomğŸ“‘ is a library which parses 
                     and interacts with assembled 
                     HTML just like a browser.

                - we will choose for JestğŸƒ to add 
                  coverage reportsâ˜‘ï¸
                -The provider for coverage will be 
                BabelğŸ¦œâ˜‘ï¸
                -We will automattically clear mock calls
                , instances, contexts and results before
                every test â˜‘ï¸

    Now we have created our jest.config.js file according
    with the options we chose for our configurationğŸ—ï¸.

    Next, let's install our jsdomğŸ“‘ libraryğŸ“š. According
    with the documentation of TestingğŸ§ªLibrary, if we
    are using JestğŸƒ 28 or later, `jest-enviroment-jsdom`
    package now must be installed separatedly.

                //ğŸ–¥ï¸inside the terminal:
                > npm install --save-dev jest-environment-jsdom

    We will need to install more LibrariesğŸ“š in the future.

ğŸŸ¢-----Writing testğŸ§ª casesğŸ’¼-----â€¢Â·

Let's write simple w test, some JavascriptğŸŸ¨ test.
For that, let's create a new componentğŸ§©, that will help us
to understand tesing. we will call it sum.js

                //ğŸ–¥ï¸inside sum.js
                export const sum = (a, b) =>{
                    return a + b
                }

    ğŸ¤”But how do we write testğŸ§ª casesğŸ’¼ for
    this component?
    If we write `npm run test` in the terminal,
    it says `No tests found`, JestğŸƒ was looking
    in all our files for testğŸ§ª casesğŸ’¼ and
    did not find any. But where is it searching?
    in the terminal you will find the answer in:

            //ğŸ–¥ï¸terminal returned:
             `testMatch: ğŸ‘‰**/__tests__/**/*.[jt]s?(x), **/?(
              *.)+(spec|test).[tj]s?(x) - 0 matches`

    JestğŸƒ was looking for thatâ¬†ï¸ folder.
    These files are present in a folder 
    that needs to be called `__test__`.

    Now, whatever files are present inside the our
    folder named __test__ğŸ“, it will track them.
    Now, like we saw, our testMatch has a configurationğŸ—ï¸
    for file extensions of .jt, jsx, or js. 

            //ğŸ–¥ï¸terminal returned:
                testMatch: **/__tests__/**/ğŸ‘‰*.[jt]s?(x), **/?(
                *.)+(spec|test).[tj]s?(x) - 0 matches`

    So any file you create, anywhere inside the folder
    structure, if is .js or jsx, it will be 
    considered a testğŸ§ª file

    otherwhise, if you can create a testğŸ§ª folder called
    .test.js or .test.ts, etc
    For example you can create Header.test.js as a test 
    file or you can also use

        Â· Headers.test.ts
        Â· Headers.spec.js
        Â· Headers.spect.js

    All those files will be considered testing files

        ğŸ¤”But what is that `__` business?
        that is syntax for dunder method of
        python, and we use it as a keyword,
        it's a convrnyion. for testsğŸ§ª, a
        reserved word for tracking testing files.

ğŸŸ¢-----creating our first JavascriptğŸŸ¨ testğŸ§ª file-----â€¢Â·

    Let's create our first testğŸ§ª file inside our __test__ğŸ“
    folder to test our sum.js componentğŸ§©. called sum.test.js

    ğŸ¤”How are we going to test our sum function?

        â€¢FIRST of all, we use a functionğŸ“½ï¸ `test`
        that takes 2 arguments, a string and a callback
        function. The string will describe the purpose of
        the function we are testing, and inside the brackets 
        of the function it will be the test. This is the rest

                //ğŸ–¥ï¸inside sum.test.js
                import { sum } from "../sum"

                    ğŸ‘‰test("sum function should sum of two numbers", ()=>{

                        //first we will call the function we want to test:
                        ğŸ‘‰const result = sum(3,4)//using some parameters

                        //this line is known as ASSERTIONğŸ«¡:
                        ğŸ‘‰expect(result).toBe(7)
                        
                        //the result has to be the same as the toBe method
                    })


        now we can run the test using `npm run test` in the terminal 
        and it will tell us that our test passed!

                //ğŸ–¥ï¸terminal returned:
                    ...
                    Test Suites: 1 passed, 1 total
                    Tests:       1 passed, 1 total
                    ...

        â—Most of the time, you will
        always have ASSERTIONsğŸ«¡ in your test, if you don't write
        an ASSERTIONğŸ«¡, it will always pass no matter what.


    ğŸŸ¢-----creating our first REACTâš›ï¸ testğŸ§ª file-----â€¢Â·

    We will be writing unit testing.
    First of all, let's run our app in a different terminal than our TestingğŸ§ª
    one. using `npm run start`.
    Let's create a basic testğŸ§ª to see if our componentğŸ§© is loaded or not. 

    We'll be using our Contact.js componentğŸ§©
    we'll try to render it, and see if it loads or not.
    But first let's fill a little bit our componentğŸ§©, since 
    it's looking quite empty.

                    //ğŸ–¥ï¸inside .parcelrc
                    const Contact = () => {
                        return (
                            <div>
                                <h1>Contact us page</h1>
                                <form>
                                <input type="text"
                                placeholder="name" />

                                <input type="text"
                                placeholder="message" />

                                <button>Submit</button>
                                </form>
                            </div>
                        );
                    }
                    export default Contact;


        â€¢ Now is time to write the test, inside a new
        componentğŸ§© inside our __test__ğŸ“ folder we
        will call `Contact.test.js`:

                    //ğŸ–¥ï¸inside .parcelrc

                    import { render, screen } from "@testing-library/react"
                        import Contact from "../Contact"

                        test(
                            "should load contact.js component", () => {

                            ğŸ‘‰render(<Contact />)//this wil render it to 
                            the js DOM

                            /*Now we will test it if it was successfully 
                            rendered:
                            For that we will use the screen() method
                            screen is an obj that comes from the 
                            testing library
                            that give us access to the component elements*/

                            /*Thanks to the screen obj, we can use the 
                            getbyRole
                            method to find all the elements with a 
                            given role value: */

                            ğŸ‘‰const heading = screen.getByRole("heading")

                            /*Now that we got our element, we can expect some results
                            by manipulating it */

                            ğŸ‘‰expect(heading).toBeInTheDocument()
                        })

        ğŸ¤”However, this test has failed, but why?
        in the terminal it shows `Support for the experimental syntax '
        jsx' isn't currently enabled`

        so JSXğŸ¦ is not enabled for our app!

        ğŸ¤”How can we enable JSXğŸ¦??
        in the terminal it shows ` Add @babel/preset-react `, So JestğŸƒ
        is helping us to solve this issue

                    //ğŸ–¥ï¸inside the terminal:
                    //For enabling JSXğŸ¦ â¬‡ï¸

                    >npm i -d @babel/preset-react

        And we will need to Include @babel/preset-react 
        inside  my BabelğŸ¦œ configğŸ—ï¸:

                    //ğŸ–¥ï¸inside babel.config.js :
                    module.exports = {
                    presets: [['@babel/preset-env', {
                        targets: { node: 'current' } }]
                        
                        /*it will automatically pick the runtime,
                            If we don't add the runtime thing, wit will
                            pick an error: â¬‡ï¸*/

                            ğŸ‘‰["@babel/preset-react", { 
                                runtime: "automatic" }]
                        
                        ],
                    };

        ğŸ¤”Why do we need this preset??
        basically, BabelğŸ¦œ is a transpiler. Right 
        now this Babel preset in react is helping
        the TestingğŸ§ªLibraryğŸ“š to convert the JSXğŸ¦
        code to XTML/html so it can read it properly

        But it continues to fail ğŸ˜­, why????
        in the terminal says `TypeError: expect(...
        ).toBeInTheDocument is not a function`

        This is because we haven't installed the 
        libraryğŸ“š for toBeInTheDocument().
        This libraryğŸ“š is jest-dom


                    //ğŸ–¥ï¸inside the terminal:
                    npm i -D @testing-library/jest-dom

        when is fixed, we can import the library to our testğŸ§ª
        file:
                    //ğŸ–¥ï¸inside Contact.test.js:
                    import "@testing-library/jest-dom";

        Once the libraryğŸ“š is included, as soon as you
        write anu ASSERTIONğŸ«¡, (an expect statement)
        vscode suggest you a lit of methods that we can
        use to testğŸ§ª our selected element.

        This time the testğŸ§ª passedâœ…

        â€¢ Let's make a render testğŸ§ª for our Submit buttonğŸ”˜.

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load button inside contact.js component", () => {

                    render(<Contact />)//this wil render it to the js DOM

                    const button = screen.getByRole("button")

                        expect(button).toBeInTheDocument();
                    })

        Â· So with this line:
        `const heading = screen.getByRole("heading")`
        the getByRole method can help you with every kind of role in the html
        this roles are defined by JestğŸƒ inside the TestingğŸ§ªLibraryğŸ“š
        there's more ways to access our button, we can also use

            - screen.getByText("Submit")
                this will look for matches of text in our screen 
                object and find our `Submit` buttonğŸ”˜

        If you try to find a non-existent eleement, the testğŸ§ª wil fail

        The beauty of JestğŸƒ is that, whenever it fails, the test, it 
        will show you what was rendered so you can see it for reference

        â€¢ Let's make a render testğŸ§ª for our placeholder text inside our
        input attribute:

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load the name input inside contact.js component", () => {

                        render(<Contact />)//this wil render it to the js DOM

                        const input = screen.getByPlaceholderText("name")

                        expect(input).toBeInTheDocument();
                    })

        â€¢ What we would do if we wanted to get Multiple the input attributes:

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load 2 input boxes inside contact.js component", () => {

                        render(<Contact />)

                        //there's not role named "input", the appropiate term is "textbox:"
                    ğŸ‘‰ const inputBoxes = screen.getByRole("textbox")


                        expect(inputBoxes).toBeInTheDocument();
                    })
        
                â—However, this will throw an error saying there are multiple elements 
                with the role "textbox" ğŸ˜± why??
                because the appropiate method to check ALL the elements with the same 
                role is getAllByRole().
                Let's use it and log into the console what do we get using this method:

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load 2 input boxes inside contact.js component", () => {

                        render(<Contact />)

                        //This is known as queryingğŸ™‹â€â™€ï¸ the getByAll()
                        const inputBoxes = screen.getAllByRole("textbox")

                        //intputBoxes will be an array of objects
                        //here we log the first element of the array:
                        console.log(inputBoxes[0])
                    })

                We get a react element with all its properties. Remember that at the
                end of the day JSXğŸ¦ is a way to write REACTâš›ï¸ elements and 
                REACTâš›ï¸ elements are OBJECTS!

                If we are queryingğŸ™‹â€â™€ï¸ we do something like screen. and add a get
                method and make things return to us!

                Now let's check with our ASSERTIONğŸ«¡ if we actually have 2 input
                boxes:

                    //ğŸ–¥ï¸inside Contact.test.js:
                    test("should load 2 input boxes inside contact.js component", () => {

                    render(<Contact />)

                    const inputBoxes = screen.getAllByRole("textbox")

                    //since our inputBoxes is an array of objects:
                    ğŸ‘‰expect(inputBoxes.length).toBe(2)
                })

                Â· We can also check a FALSE amount using the `not` keyword:
                - expect(inputBoxes.length).not.toBe(3)
        
    These were only the basics of TestingğŸ§ª, some important things:

    ğŸš¨Remember: when TestingğŸ§ª you will allways need to

        1ï¸âƒ£ RENDERğŸ–Œï¸ something
        2ï¸âƒ£ QUERYğŸ™‹â€â™€ï¸ something
        3ï¸âƒ£ ASSERTğŸ«¡ something

    ğŸš¨Remember that `test()` is the name of the function, you can 
    also use `it` like this: 

                //ğŸ–¥ï¸inside Contact.test.js:
                    ğŸ‘‰it("should load 2 input boxes inside contact.js component", () => {
                    ...
                })

        There's no Difference!!!!!! it() is just an alias of test()

    ğŸš¨Remember to hover over the methods in VSCODE if you don't understand any,
    it will typically provide explanations on how the code works

ğŸŸ¢-----Managing Multiple testğŸ§ª casesğŸ’¼ USING describeğŸ–‹ï¸-----â€¢Â·

    We have now written several testğŸ§ª casesğŸ’¼
    Sometimes the number of testsğŸ§ª becomes unmanageable,
    in that circumstance, we can put them in group, 
    that means, puting all the testğŸ§ª casesğŸ’¼ inside
    a block code  named describeğŸ–‹ï¸.

    Let's use describeğŸ–‹ï¸ to contain all our Contact.js
    testğŸ§ª cases:

                //ğŸ–¥ï¸inside Contact.test.js:
                describe("Contact us Page test cases", () => {

                test("should load contact.js component", () => {...})

                test("should load the name input inside contact.js component", () => {...})

                test("should load 2 input boxes inside contact.js component", () => {...})

                });


        ğŸš¨Everything works the same, this is just for grouping testsğŸ§ª

        â•you can also nestğŸªº one describeğŸ–‹ï¸ in another describeğŸ–‹ï¸
        â•You can have multiple describeğŸ–‹ï¸ in a single file
        â•



ğŸŸ¢-----CoverageğŸ“-----â€¢Â·

As we can see inside our projects,t there are many more files
than before. This is because our CoverageğŸ“ and the new files
it contains, it was added with JestğŸƒ in order to have the 
capacity to cover all our files in our TestingğŸ§ª

This file is inside our Dependenciesâ›“ï¸ so is not necessesary
to push it to our GitğŸˆâ€â¬› repository, so we can put it inside
our `.gitignore` file:


                //ğŸ–¥ï¸inside Contact.test.js:
                /node_modules/
                /dist/
                /.parcel-cache/
                ğŸ‘‰/coverage/


ğŸŸ¢-----TestingğŸ§ª our Header componentğŸ§©-----â€¢Â·

    ğŸš¨Remember that we are making Unit TestingğŸ§ª, now we are going to test
    our header componentğŸ§© to see if:

        - It loads the LoginğŸ” buttonğŸ”˜
        - our CartğŸ›’ element starts with 0 elements inside

    so to start, we create a new testing file called Header.test.js

                //ğŸ–¥ï¸inside Header.test.js:
                describe("Contact us Page test cases", () => {
    
                    it("Should load Header Component with a 
                    login button", ()=>{
                        render(
                            <Header/>
                        )
                    })
                })

    â—However, this throws an ERROR, that is because our CartğŸ›’
    functions with Redux, so we will have to provide Redux to our
    componentğŸ§© using <Provider> and provide our appStore
    so it has access to our Redux code

                //ğŸ–¥ï¸inside Header.test.js:
                describe("Contact us Page test cases", () => {
    
                    it("Should load Header Component with a 
                    login button", ()=>{
                        render(
                            <Provider store={appStore}>
                            <Header />
                            </Provider>
                        )
                    })
                })


    â—However, this throws an ERROR, because Header element
    



      