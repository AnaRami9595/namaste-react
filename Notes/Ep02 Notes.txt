----------Notesâœï¸--------

ğŸ”µ------------ What is NPM?ğŸ ------------

It is NOT Node package management
It manages packages but it doesn't stand for that. It a standard repository for all packages.
Any package you need to include in your code, you can use npm.

    ğŸ¤”How can you make your project use NPM?
    let's make our project use normaldo

        ğŸ’»"npm init"
        entry point: (index.js)

ğŸ”µ------------ What is package.jsonğŸŠ ------------

It is a configuration for NPMğŸ

    ğŸ¤” Why do we need it?
    Our project depends of a lot of packages, those packages our project is depending upon,  are called
    Dependenciesâ›“ï¸. NPMğŸ manages that. NPMğŸ will take care of the version of that package.

ğŸ”µ------------ Dependenciesâ›“ï¸ ------------

We are going to install the most important package in our project: A BundlerğŸ“š

    ğŸ¤”What is a BundlerğŸ“š
    Our whole code needs to be bundled together, neat before send to production. A BundlerğŸ“š helps you
    do that. Webpack, ParcelğŸ“¦, are exemples of BundlersğŸ“š. They package your app properly so it can be
    send to production. When you use the create-react-app command, it uses Webpack and Babel
    behind the scenes. In our project we will be using ParcelğŸ“¦.

        ğŸ’»"npm install -D parcel"
        //To Install ParcelğŸ“¦ in our project 

    ğŸ¤”What does the "-D" mean??
    There are 2 types of Dependenciesâ›“ï¸: Normal Dependencyâ›“ï¸ and Dev ğŸ¤“ Dependencyâ›“ï¸

        - A DevğŸ¤“ Dependencyâ›“ï¸ is regularly required when we are Building our app.
        We will use ParcelğŸ“¦ as a DevğŸ¤“ Dependencyâ›“ï¸ to build our app in our development phase
        with the expression "npm install -D parcel" we are informing NPMğŸ That we will use
        this BundlerğŸ“š as a DevğŸ¤“ Dependencyâ›“ï¸, therefore the "-D".
        We are fetching ParcelğŸ“¦ from NPMğŸ, which manages ALL the packages!!

        - A normal Dependenciesâ›“ï¸ is used in production also.

    Now that we installed ParcelğŸ“¦, it shows on package.jsonğŸŠ as a Dependencyâ›“ï¸: "

        ğŸ’»"devDependencies": {
        "parcel": "^2.9.3"
        }

    ğŸ¤”What does the "^" mean?? (TANGENT!!!)
    This symbol is known as Caret.  In a package.jsonğŸŠ file, both "^" and "~" are used
    as part of version range specifiers for declaring the allowed range of versions for a
    package's Dependencyâ›“ï¸. They are used to manage version compatibility when installing and
    updating packages.

    ğŸ’¡Here's the difference between "^" and "~"

        â¹ï¸1. Caret ("^")
        When you use the caret symbol "^" you're specifying a version range that allows for
        non-breaking  updates. It will update to any version that is compatible with the specified
        version but avoids breaking changes. The caret taes the highest compatible version that is
        not considered a breaking change. Always include this symbol in your versions â—

        For example, in this case we are usin ParcelğŸ“¦ version "^2.9.3" it means any version from
        "2.9.3" up to, but NOT including "3.0.0" is allowed, so it might install "2.8.3", but not
        "3.0.0"

        â¹ï¸2. Tilde ("~")
        When you use the tilde symbol ("~") you're specifying a version range that allows for patch
        updates. It will update to any version that is compatible with the specified version, but it
        won't allow updates that include new minor versions. Only patches (BugğŸª² fixes) are allowed
        within the same minor version.

        For example, if we specified our ParcelğŸ“¦ version as "~2.9.3" it means any version from
        "2.8.3" up to, but not including "2.9.0". So it has less flexibility than Caret ("^").


    ğŸ¤”What does "package-lock.jsonğŸŠ" do?
    Now we have a new jsonğŸŠ file!! "package-lock.jsonğŸŠ",ğŸ¤” what is the difference with the
    other package "package.jsonğŸŠ"?

    ğŸ’¡Here's the difference between "package-lock.jsonğŸŠ" and "package.jsonğŸŠ"

        â¹ï¸1. "package.jsonğŸŠ"
        Like we mentioned, is a configuration file for NPMğŸ, It keeps track of the range of
        versions of the packages that are installed into our system.

        - It contains metadata  about your project. Including its name, version, description, author,
        license.

        - Also the "scripts" section allows you to define custom commands that can be executed using
        "npm run <script-name>". This is commonly used for tasks like building, testing and running
        the app.

        -The most important thing: includes the list of Dependenciesâ›“ï¸ your project relies on, along
        with the version ranges required for those packages. These version ranges are used y npm to
        determine which versions of Dependenciesâ›“ï¸ to install when you run "npm  install.
        However, these ranges can sometimes lead to inconsistencies if not managed properly, which is
        where "package-lock.jsonğŸŠ" comes in.

        â¹ï¸2. "package-lock.jsonğŸŠ"
        It keeps track of ALL Dependenciesâ›“ï¸
        Introducedd in npm version5, the "package-lock.jsonğŸŠ" file is automatically generated and
        updated whenever you install or modify Dependenciesâ›“ï¸ in your project. It locks down the
        specific versions of all installed packages, along with their sub-dependencies, to ensure
        that the same versions are used consistently across different enviroments and installations,
        ensuring consistency and predictability during development and deployment.

    ğŸ¤”What does "node_modulesğŸ”°" do?
    When we installed ParcelğŸ“¦, a folder "node_modulesğŸ”°" was generated in our project. It contains
    all the code that we fetched from NPMğŸ.  So "package.jsonğŸŠ: contains the METADATA for NPMğŸ but
    "node_modulesğŸ”°" contains the actual DATA of our Dependenciesâ›“ï¸ Is like a Data base.
    The file is so huge is kind of a meme ğŸ˜….

    ğŸ¤”"node_modulesğŸ”°" includes a ParcelğŸ“¦ file, but what do we have so many files if we only want ParcelğŸ“¦?
    It comes like this because ParcelğŸ“¦ as a project has its own Dependenciesâ›“ï¸ and those Dependenciesâ›“ï¸
    have their own,

        ğŸ’¡those are called TRANSITIVE Dependenciesâ›“ï¸â—
        also known as indirect Dependenciesâ›“ï¸, those are Dependenciesâ›“ï¸ that your project Dependenciesâ›“ï¸
        rely on. The Dependenciesâ›“ï¸ of your Dependenciesâ›“ï¸

    ParcelğŸ“¦ is a beast and, can't work on it's own! It also uses BabelğŸ—£ï¸, browsers, etc. Those are coming
    from NPMğŸ, which manages all the packages!!

    ğŸ¤”How does NPMğŸ know that ParcelğŸ“¦ has its own Dependenciesâ›“ï¸?
    Every dependency and TRANSITIVE Dependencyâ›“ï¸ included in our "node_modulesğŸ”°" file has a "package.jsonğŸŠ"
    and a "package-lock.jsonğŸŠ" of its own that manage their own Dependenciesâ›“ï¸. "node_modulesğŸ”°" is a collection
    of our Dependenciesâ›“ï¸.

    ğŸ¤”When pushing our project to GitğŸˆâ€â¬›, should we add the "node_modulesğŸ”°" file?
    NO! Since it's huge as compared  to the sice of our code.

    - The Best Practiceâœ… is to put node_modulesğŸ”° inside a file called ".gitignoreğŸ›‘"
      Inside ".gitignoreğŸ›‘" we write

                ğŸ’»"/node_modules/"

    - However, "package.jsonğŸŠ" and a "package-lock.jsonğŸŠ" should be sent to production and we need to add them
      to our GitğŸˆâ€â¬› push. Because mantain a metadata of all the dependencies our project need to funtion. So
      Whatever is in our local needs to be  sent to production. But remember, no "node_modulesğŸ”°".
      If you have "package.jsonğŸŠ" and a "package-lock.jsonğŸŠ", you can recreate aaaall the necessary "node_modulesğŸ”°".

      If you delete the "node_modulesğŸ”°".  file, you can install it later using ğŸ’»"npm install" in my repository.

        ğŸ’¡Remember: A rule of thumb is, if you can recreate anything later DON'T put it on GitğŸˆâ€â¬›, if you CAN'T recreate
        it, PUT IT ON GitğŸˆâ€â¬›. Git must only carry essential thingsâ—

ğŸ”µ------------ Build our App using ParcelğŸ“¦ ------------

Terminal:

            ğŸ’»"npx parcel index.html"
            //ParcelğŸ“¦ will create a server for us called  http://localhost:1234
            //ğŸ’¡The NPXğŸ’£ is a command to execute a package. NPMğŸ is for installing a packageâ—

    ğŸ¤”What is NPXğŸ’£ and NPMğŸ used for?

        â¹ï¸1.  NPMğŸ
        Like the CDN Links we used in our "index.html" file, NPMğŸ can be used to inject react in our
        project.
        â—Using CDN codes is NOT a good way to bring REACTâš›ï¸ in our project, because fetching from CDN is a costly
        operation: it makes an external call to get it, the best thin would be if it was already stored
        locally inside our package.jsonğŸŠ

        ğŸ’¡In order to get REACTâš›ï¸ locally we install it to our project using:

            ğŸ’»"npm install react"
            //â—Notice that we did not include the "-D" in our command, that is because we need react
            as a normal Dependency, not as a DevğŸ¤“ Dependencyâ›“ï¸

        ğŸ’¡Just like we imported ReactDOMğŸ“ƒ using CDN links, we also needd to import ReactDOMğŸ“ƒ using NPMğŸ
        If that is the way we are going to get it. So we install it:

            ğŸ’»"npm install react-dom"
            //sometimes we can see it as npm i react-dom, is an abreviation.
            //âŒThis brings an error in the console "Uncaught ReferenceError: React is not defined" ğŸ˜±
            //ğŸ¤”How do we fix this??

        ğŸ’¡See, we only INSTALLED REACTâš›ï¸ package in our node modules, but our code does not have it.
        ğŸ¤”How do I use it in my code? Inside App.js, at the top of the page,
        we import REACTâš›ï¸ from the "node_modulesğŸ”°" directory.

            ğŸ’»"import React from "react";"
            //We are getting it from the REACTâš›ï¸ folder called "react" that is inside our node_modulesğŸ”°

        ğŸ’¡We also need to import ReactDOMğŸ“ƒ from our node_modulesğŸ”° so we write

            ğŸ’»"npm install react-dom"//In the terminal
            ğŸ’»""import ReactDOM from "react";//â¬…ï¸This we write to import ReactDOMğŸ“ƒ To App.js
            //âŒThis brings an error in the console "@parcel/transformer-js: Browser scripts cannot have imports or exports" ğŸ˜±
            //âŒIt also indicates that the error is here "<script src="App.js">"
            //ğŸ¤”What does it mean??

        ğŸ’¡Basically, on our "index.html" file we are injecting JavascriptğŸŸ¨ using the tag  "<script src="App.js">"
        so the BrowserğŸŒ treats this script as a normal JavascriptğŸŸ¨ file, but it is not, because is REACTâš›ï¸ and
        normal JavascriptğŸŸ¨ Does not do imports like "import React from "react". So we need to tell our BrowserğŸŒ
        that this file is not a normal JavascriptğŸŸ¨ file, is a MODULEğŸ“, we tell it writing inside "index.html":

            ğŸ’»"<script type= "module" src="App.js">"
            //now react work and our page looks as expected
            //Now, every time we update our code, our BrowserğŸŒ is automatically refreshed thanks to ParcelğŸ“¦:

ğŸ”µ------------ ParcelğŸ“¦ ------------

How does it work?

        ğŸ’¡The powers of ParcelğŸ“¦:

        -BundlerğŸ“š

        -Parcel just created a Dev Build for you

        -It also created a local server for you

        -HMRğŸ”¥ =  Hot Module Replacement. This is what automatically refreshes our page. It does that because it
         has a File wathing Algorithm that is written in C++, that keeps track of all our files.

        -Caching ğŸ•¸ï¸ Faster Builds because of caching. It takes less and less time to build, because of the file
         ".parcel-cacheğŸ•¸ï¸" that generates inside our main folder, so that the next app Builds develop faster.
         The same code is never built twice.

        -Image OptmizationğŸ–¼ï¸

        -Minification of our file

        -File CompressingğŸ—ƒï¸

        -Consistent Hashing ğŸ•§ = Is like a clock that helos decide which computer should take care of storing and
        finding different pieces of data. Is a smar way to balance the work among the computers and make sure that
        things keep running smoothly, even when the group of computers changes over time.

        -Code Splitting

        -Differential Bundling = can BundleğŸ“š the app so it is compatible for different type of app and BrowsersğŸŒ

        -Diagnostincs behind the scenes ğŸ©»

        -Error Handling âœ–ï¸

        -Gives you the option to work in HTTPs

        -Tree Shaking AlgorithmğŸ„ - will remove unused code for you

        -Different  DevğŸ¤“ and ProductionğŸ‘·ğŸ»â€â™€ï¸ BundlesğŸ“š, If you would like to execute a ProductionğŸ‘·ğŸ»â€â™€ï¸ Build you can write:
         in the terminal

                ğŸ’»"npx parcel build index.html"
                //In our current app, this will give us an ErrorâŒ because inside our "package.jsonğŸŠ" file we have our main
                //as "main": "App.js" which is a way to tell npm that is our entry point to our app

                ğŸ’¡Important!!!! You don't need "main": "App.js", when you're using ParcelğŸ“¦, so remove it!!
                it was originaly under "description".


        REACTâš›ï¸ is not fast in itself, it uses ParcelğŸ“¦ and other BundlersğŸ“š to be fast. And they use Dependenciesâ›“ï¸
        to work better

    ğŸ¤”What is the "distğŸ“‚" folder that is generated in our app?
    ParcelğŸ“¦ and REACTâš›ï¸ will make their magic and send the resulting code to the distğŸ“‚ folder, the content inside the
    distğŸ“‚ folder is what is showing up in the BrowserğŸŒ.

    When you execute NPXğŸ’£ in ParcelğŸ“¦ using "npx parcel index.html" it genereates a DevğŸ¤“ build for your project,
    and it host it, when is generating the code, puts it inside the distğŸ“‚ folder. If you make a ProductionğŸ‘·ğŸ»â€â™€ï¸ build. It
    generates a distğŸ“‚ file for its own, which is heavier and includes additional html files, css, js, that will serve
    as a compressing of all our modules that we write, is the ProductionğŸ‘·ğŸ»â€â™€ï¸ ready version of your code.

    ğŸ¤”Can we recreate the ".parcel-cacheğŸ•¸ï¸" folder??
    Yes!! if it's deleted, you can always regenerate it using the NPXğŸ’£ command "npx parcel index.html" or
    "npx parcel build index.html". Remember, anything that can be reacreated later we don't have to push to GitğŸˆâ€â¬›, so
    we'll add it to .gitignoreğŸ›‘

ğŸ”µ------------ Git ğŸˆâ€â¬› ------------

We usually push our code from 
        
        Our Local ServerğŸ§‘ğŸ»â€ğŸ’» â¡ï¸â¡ï¸â¡ï¸ to GitğŸˆâ€â¬› â¬…ï¸â¬…ï¸â¬…ï¸ Which is deployed to a ServerğŸ–²ï¸, (that fetches the code from GitğŸˆâ€â¬›)
        Then, the code goes from the  ServerğŸ–²ï¸ â¡ï¸â¡ï¸ to the User ğŸ‘¤
        
        -All the commands that we write from our Local ServerğŸ§‘ğŸ»â€ğŸ’» (npx parcel, etc) will be able to be used in the ServerğŸ–²ï¸ also.
        -We will send package.jsonğŸŠ to GitğŸˆâ€â¬› but not our node_modulesğŸ”°, since the ServerğŸ–²ï¸ has their own node_modulesğŸ”° copy.
        -Inside the ServerğŸ–²ï¸, they also have their own distğŸ“‚ folder, so we don't need to push it, we'll save it inside gitignoreğŸ›‘


ğŸ”µ------------ Let's make our app compatible for all the versions of BrowsersğŸŒ ------------

In order to do that we'll need to use an NPMğŸ package called browserslistğŸ“‚, that it can be found inside node_modules, 
we need to tell browserslistğŸ“‚ what browser do I need to support my app.
AkshayğŸ‘¨ğŸ¾â€ğŸ¦± recommends the website ğŸŒhttps://browserslist.dev/ to know the stadistics of users with latests version of BrowsersğŸŒ
BrowsersğŸŒ List is a great tool to reach as much as people as possible

        1. Inside our package.jsonğŸŠ file we need to add the following at the end:

                    ğŸ’»"browserslist": [
                        "last 2 Chrome version",
                        "last 2 Firefox versions"
                        "last 2 versions"//for all the browsers
                    ]

    
//Our App.js looks like this now:

                       ğŸ–¥ï¸ import React from "react";
                        import ReactDOM  from "react-dom";


                        const parent = React.createElement("div", { id: "parent" }, [
                            React.createElement("div", {id:"child"}, [
                                React.createElement("h1", {}, "I'm an h1 tag"),
                                React.createElement("h2", {}, "I'm an h2 tag")
                        ]),
                        React.createElement("div", {id:"child2"}, [
                            React.createElement("h1", {}, "I'm another h1 tag"),
                            React.createElement("h2", {}, "I'm another h2 tag")
                        ]),
                        ]);

                        console.log(parent)

                        const root = ReactDOM.createRoot(document.getElementById("root"));

                        root.render(parent)


