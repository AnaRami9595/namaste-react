ğŸ”´-----Data inside a REACTâš›ï¸ app------

It is important that we learn the concept of  
higher order componentsğŸ§©

ğŸ”´-----Higher order componentsğŸ§©------
It is a Function that takes a componentğŸ§© 
and returns a componentğŸ§©.
At the end of the day is a normal JSğŸŸ¨ function.

It takes a componentğŸ§© as an input, and then 
modifies it with the function, enhancing it,
tweaks it a little and then retuns it back as a 
new componentğŸ§©

ğŸ”´-----Creating a Higher order componentğŸ§©------
We are going to use Higher order componentsğŸ§© to tweak
a little our restaurantcards. We will use the property
"is promoted" inside each restaurant data to put a banner
on every restaurant with a "promoted status"

                //ğŸ–¥ï¸Inside our Body.js
                ...
                return(
                    <div className="res-container
                flex  flex-wrap justify-center
                ">
                    {filteredRestaurants.map(restaurant => (
                        <Link
                            key={restaurant.info.id}
                            to={"/restaurants/" + restaurant.info.id}>

                logic here ğŸ‘‰{/*If the restaurant is promoted, then add a promoted
                            label to it */}

                            <RestaurantCard resData={restaurant} />
                        </Link>
                    ))}
                
                    </div>
                 );

ğŸ¤”But how do we make a Higher order componentğŸ§©?

ğŸ”¹We will start inside our RestaurantCard.jsğŸŸ¨ component, adding
  a High order function that will receive the function 
  RestaurantCard as an input and return a new component that is the
  exact same as RestaurantCard but with a label on top of it:

                //ğŸ–¥ï¸Inside our RestaurantCard.js:
                const RestaurantCard = (props) => {...
                }

                //Higher order component here:
                //input: RestaurantCard.js
                //output: a new component RestaurantCardPromoted:

                ğŸ‘‰const withPromotedLabel = (RestaurantCard) => {
                return () => {
                    return (
                            <div>
                                <label>Promoted </label>
                                <RestaurantCard/>
                            </div>
                        )
                    }
                }

                export default RestaurantCard;


ğŸ”¹Now let's go to our Body.jsğŸŸ¨ componentğŸ§© and import the function
  and create a variable with our function inside it

                  //ğŸ–¥ï¸Inside our Body.js
                ...
                import RestaurantCard, { withPromotedLabel 
                } from "./RestaurantCard";
                ... 
                const Body = () => {
                    ...
                      const RestaurantCardPromoted = withPromotedLabel(
                        RestaurantCard)
                    ...
                }

ğŸ”¹Now let's write the logic that will make our RestaurantCard
  componentsğŸ§© appear with a label or not depending if the 
  property "promoted" is falsy or truthy. 
  And don't forget to pass the props in any of the 2 cases so our
  componentsğŸ§© can use the data we are fetchingğŸ•!

                  //ğŸ–¥ï¸Inside our Body.js
                ... 
                const Body = () => {
                    ...
                <div className="res-container
                    flex  flex-wrap justify-center
                    ">
                    {filteredRestaurants.map(restaurant => (
                        <Link
                            key={restaurant.info.id}
                            to={"/restaurants/" + restaurant.info.id}
                        >
                        ğŸ‘‰{restaurant.info.promoted ? (
                                <RestaurantCardPromoted resData={restaurant} />
                            ) : (
                                <RestaurantCard resData={restaurant} />
                            )}
                        </Link>
                    ))}
                </div>
                }


ğŸ”¹And back to our RestaurantCard.jsğŸŸ¨, the props that we just passed
to our RestaurantCardPromoted can be accesed inside the new component
that our function withPromotedLabel() is returning!!

Just as we passed props to our RestaurantCard componentğŸ§© inside 
Body.jsğŸŸ¨, we will pass the appropiate props inside the componentğŸ§©
that withPromotedLabel() is returning, we are using it the same
way as Body.js is now, with the same data passed as props.

                  //ğŸ–¥ï¸Inside our RestaurantCard.js
                  ...
                  const withPromotedLabel = (RestaurantCard) => {
                    ğŸ‘‰return (props) => {
                        return (
                            <div>
                                <label>Promoted </label>
                              ğŸ‘‰<RestaurantCard {...props}/>
                            </div>
                        )
                    }
                }

ğŸ”´-----ControledğŸ‘® and uncontroledğŸ¦¹ componentsğŸ§©------
All the react applications have 2 layers 

    - the UIğŸ–¼ï¸ layer:
        - Powered by data layer
        - It mainly consist on the JSX Code: the local vars,
        the thigs that you use to modify your data using
        JSX Is UIğŸ–¼ï¸ layer

    - the DatağŸ§® layer
        - consist of the states, props, local variables,

If you know how to manage the DatağŸ§® Correctly in your applications,
they will be super fast.


ğŸ”´-----Creating categories------
Let's createe new features for our app, inside our
data we can see different categories for our Menu Items,
perhaps we can separate all the items per category.

Essentially we will make an acordionğŸª— type UIğŸ–¼ï¸ 
What Akshay did:

    ğŸ”¹Frst, inside RestaurantMenu he filtered all the cards
    that contain the property `@type`. In our case, we are using
    a server, so I think all the food options have a category.

    ğŸ”¹Insiide our RestaurantMenu componentğŸ§© we will write the logicf
    for our accordions, to do that, for each category we will need
    to build an accordion. Time to create an AccordionğŸª— componentğŸ§©.
    First here's the logic for a SINGLE AccordionğŸª— without 
    looping all the data:

                Let's start by making our componentğŸ§©:

                ğŸ–¥ï¸//
                const RestaurantCategory = (props) => {
                    return(
                        <div>
                            {/*Header here*/}
                            res category
                            {/*Body here*/}
                        </div>

                    )
                }

                    export default RestaurantCategory


    ğŸ”¹Now let's import it to RestaurantMenu.jsğŸŸ¨ so we can make appear
    a RestaurantCategory componentsğŸ§© for each category

    ğŸ”¹What I did is, inside RestaurantMenu, created an array of all the 
    categories of a restaurant menu,
    then, in order to avoid repetitions, I made a set of that array and 
    pass i as propsğŸ¥  along with the entire foodOptions Array so I 
    can use the data later, here's the code:

                ğŸ–¥ï¸//Inside RestaurantMenu.jsğŸŸ¨
                const RestaurantMenu = () => {
                    ...
                    const categories = foodOptions.map((item) => item.category)
                    const setOfCategories = [...new Set(categories)]

                    return (
                        ...
                          <hr></hr>
                        <div className=""
                        >
                        ğŸ‘‰{
                            setOfCategories.map(category => (
                                <RestaurantCategory key={s
                                etOfCategories.indexOf(category)}
                                    data={category}
                                    foodOptions={foodOptions}
                                />
                            ))}
                        
                    </div>
                    )
                    }

    ğŸ”¹And Inside RestaurantCategory.jsğŸŸ¨ I imported the props
    and display the names of the categories along with the number 
    of Items that it has on the menu, I did this by looping through
    foodOptions and comparing each category with each of the elements
    of the set.

                ğŸ–¥ï¸//Inside RestaurantCategory.js:
                const RestaurantCategory = (props) => {

                const { data, foodOptions } = props


                const itemsPerCategory = (data) => {
                    let sum = 0;
                    foodOptions.forEach(element => {
                        if (element.category === data) {
                            sum += 1
                        }
                    })
                    return sum
                }

                return (
                    <div>
                        {/*Header here*/}
                        <div className="w-6/12 
                        my-4 mx-auto
                        bg-slate-200 p-4
                        shadow-sm
                        flex
                        justify-between
                        font-bold text-base ">
                            <span>{data} ({itemsPerCategory(data)})</span>
                            <span>ğŸ”½</span>

                        </div>
                        {/*Accordion Body missing here*/}

                    </div>
                    )
                }

    ğŸ”¹â—â—â—F helped me correct the code for RestaurantMenu.jsğŸŸ¨
    we created an empty object and mapped foodOptions to 
    mappedOptions:
    This code maps the array of objects into an object named
    mappedOptions where keys are category names and values
    are arrays of menu items for each category. This is done
    to group menu items by their categories for rendering

                ğŸ–¥ï¸//Inside RestaurantMenu.jsğŸŸ¨
                const RestaurantMenu = () => {
                    ...
                    ğŸ‘‰const mappedOptions = {}

                    ğŸ‘‰foodOptions.forEach((o) => {

                        const cat = o.category;

                        if (mappedOptions[cat]) {
                            mappedOptions[cat].push(o);
                        }
                        else {
                            mappedOptions[cat] = [o];
                        }
                    })
                    ...
                }

    ğŸ”¹â—â—â—Then we loop to Create `categoriesList`: A `categoriesList`
    array is created by looping through the `mappedOptions` object
    using `Object.entries`. For each category, it creates
    a RestaurantCategory componentğŸ§©, passing the category name as 
    (`key`) and the array of food options for that category as `data`

                ğŸ–¥ï¸//Inside RestaurantMenu.jsğŸŸ¨
                const RestaurantMenu = () => {
                    ...
                    foodOptions.forEach((o) => {

                    const cat = o.category;

                    if (mappedOptions[cat]) {
                        mappedOptions[cat].push(o);
                    }
                    else {
                        mappedOptions[cat] = [o];
                    }
                 })


                ğŸ‘‰categoriesList = [];

                ğŸ‘‰for (const [key, value] of Object.entries(
                    mappedOptions)) {
                categoriesList.push(<RestaurantCategory key={key}
                        data={key}
                        foodOptions={value}
                    />)
                }

                }

    ğŸ”¹We need to display an item list for each category, so using
    the props inside our RestaurantCategory.jsğŸŸ¨ componentğŸ§© we
    map our foodOptions array and pass the items as props

                ğŸ–¥ï¸//inside RestaurantCategory.jsğŸŸ¨
                const RestaurantCategory = (props) => {

                const { data, foodOptions } = props
                ...
                ğŸ‘‰const options = foodOptions
                .map((option, index) => (
                    <ItemList key={index} items={option} />
                ));

                }

    ğŸ”¹Now we can use the list of Items inside our ItemList componentğŸ§©


ğŸ”´-----Making the AccordionğŸª—------

We're still missing the AccordionğŸª— body,
Let's add the functionality of expanding and minimizing the 
acordionğŸª—:

    ğŸ”¹For that we're going to add a handleClick function that 
    is called when the category is clicked.
    Inside our RestaurantCategory componentğŸ§© let's add an
    onClickğŸ–±ï¸attribute that is going to show or hide our
    accordion'sğŸª— body

                ğŸ–¥ï¸//inside RestaurantCategory.jsğŸŸ¨
                 return (
                    ...
                    <div className="
                    cursor-pointer"
                 ğŸ‘‰onClick={handleClick}>
                    <span>{data} ({itemsPerCategory(data)})</span>
                    <span>ğŸ”½</span>
                </div>
                 )

    ğŸ”¹Next, we create a state variable that will show or
    hide the items, the default state will be "false" so
    the items will be hidden 

                ğŸ–¥ï¸//inside RestaurantCategory.jsğŸŸ¨
                const RestaurantCategory = (props) => {
                ...
                ğŸ‘‰const [showItems, setShowItems] = useState(false)
                ...
                }

    ğŸ”¹ we write the function's logic, basically it will change
    to the oposite value of the state variable whenever the 
    <div> is clicked (if the items are not showing, it will show, 
    and if they're showing, they will hide):

                ğŸ–¥ï¸//inside RestaurantCategory.jsğŸŸ¨
                const RestaurantCategory = (props) => {
                ...
                const [showItems, setShowItems] = useState(false)
                ...
                ğŸ‘‰const handleClick = () => {
                 setShowItems(!setShowItems)
                }
                }

ğŸ”´-----Collapsing the AccordionğŸª—------

Let's create  a new feature that will colapse the other accordion 
when one is opened. For this we are going to learn an important
concept in REACTâš›ï¸:

        ğŸ’¡Interview question:ğŸ’¡
        ControledğŸ‘® AND UncontroledğŸ¦¹ components.
        An uncontroledğŸ¦¹ component manages itself, 
        a ControledğŸ‘® component, depends on their parent to function

In this case, our RestaurantCategory componentğŸ§© was regulating itself since
it had it's own showItems stateâ˜ï¸. In order to create the feature we want, we need
to give the control to the parent componentğŸ§© RestaurantMenu.jsğŸŸ¨ so it can decide
which AccordionğŸª— need to open or close. That way, our RestaurantCategory.jsğŸŸ¨
will become a ControledğŸ‘® component. 

    ğŸ”¹In order to do that, inside our RestaurantMenu componentsğŸ§©, let's pass the 
    variable "showItems" as one of the propsğŸ¥ . Now we will get this property inside
    our RestaurantCategory componentğŸ§© directly from our parent: 


                ğŸ–¥ï¸//inside RestaurantMenu.jsğŸŸ¨

                const RestaurantMenu = () => {
                    ...
                    categoriesList = [];

                    for (const [key, value] of Object.entries(mappedOptions)) {
                        categoriesList.push(<RestaurantCategory key={key}
                            data={key}
                            foodOptions={value}
                        ğŸ‘‰showItems={true}
                        />)
                    }
                    ...
                    return(...)
                }

    ğŸ”¹Now we can use that value to show or hide our items. Since we passed the value 
    as true, all our AccordionsğŸª— will be open. Make sure to delete the previous
    stateâ˜ï¸ variable and handleClick

                ğŸ–¥ï¸//inside RestaurantCategory.jsğŸŸ¨

                const RestaurantCategory = (props) => {

                const { data, foodOptions, showItems } = props
                }


    ğŸ”¹But we don't want, that! we would like to open 1 AccordionsğŸª— at a time. 
    Let's say
    we only want to show the first category items, we can do it like this: 


                ğŸ–¥ï¸//inside  RestaurantMenu.jsğŸŸ¨
                const RestaurantMenu = () => {
                ...
                ğŸ‘‰const [showIndex, setShowIndex] = useState(0);
                /*this â¬†ï¸ variable will be used to keep track of 
                the index of the Category to display with showItems
                set to true*/

                 ğŸ‘‰const categoriesList = Object.entries(
                    mappedOptions).map(([
                    key, value], index) => (
                    <RestaurantCategory
                        key={key}
                        data={key}
                        foodOptions={value}
                        showItems={index === showIndex ? true : false}
                    />
                ));
                return(...)

                }

                /*The categoriesList variable creates an array
                by mapping over the entries of `mappedOptions ` object
                using the Object.entries method. The map function 
                iterates through each key (category name) and value
                (array of objects that are the menu items) for each
                entry. Additionally, it provides an index parameter
                which represents the index of the current iteration.
            

    ğŸ”¹Now we will like to control the setShowIndex function in
    order to open each RestaurantCategory by clicking them and
    activating our handleClick funtion. We can pass the function
    as a prop like this: 

                ğŸ–¥ï¸//inside RestaurantMenu.jsğŸŸ¨
                   const categoriesList = Object.entries(
                    mappedOptions).map(([
                    key, value], index) => (
                    <RestaurantCategory
                        key={key}
                        data={key}
                        foodOptions={value}
                        showItems={index === showIndex ? true : false}
                     ğŸ‘‰setShowIndex={() => setShowIndex(index)}
                        />
                    ))
                    
                    /*This will allow to apply the function 
                    setShowIndex to each category, passing their
                    particular index as an argument, so when clicked,
                    the function will be called with its index, effectively
                    showing itself or remaining hidden when other 
                    category is clicked: */

    ğŸ”¹Finally, we import the prop inside RestaurantCategory so we can
    get this behavior.

                ğŸ–¥ï¸//inside RestaurantCategory.jsğŸŸ¨
                    const { data, foodOptions, 
                    showItems, setShowIndex } = props

                    const handleClick = () => {
                        setShowIndex();
                    }
                    return (
                        ...
                        <div 
                            onClick={handleClick}
                        >
                            <span>{data} ({itemsPerCategory(data)}
                            )</span>
                            <span>ğŸ”½</span>
                        </div>
                    )


        ğŸ’¡Interview question:ğŸ’¡
        Lifting state up ğŸ”
        This is when you want to coordinate two components so you
        move their state to their common parent, then pass the 
        information down through props from their common parent.
        Finally, pass the event handlers doen so that the children
        can change the parent's state. It's useful to consider
        components as "controlled" (driven by props) or uncontrolled
        (driven by state)


ğŸ”´-----Creating a contextğŸ“– ------

Props DrillingğŸ—ï¸:
Also known as prop chaining or prop threading, is a process of
passing data from a top-level componentğŸ§© to a deeply nested 
child componentğŸ§© by passing data by props. This is a problem
and is inneficient 

React Context ğŸ“–
This is a way to solve the propsğŸ¥  DrillingğŸ—ï¸ problem, by Creating
a global context that we can invoke anywhere inside the app without
needing to pass DatağŸ§® by props repeatedly.

Let's create a REACTâš›ï¸ ContextğŸ“– that can contain information
useful throughout the app. A perfect example for this could be user
info. 


    ğŸ”¹Let's create a ContextğŸ“– inside our utilsğŸ“ folder named
    UserContext.jsğŸŸ¨.Now inside it, we can use an important 
    REACTâš›ï¸ superpower that is a variable named createContext
    That we have access through the react library. It is like a 
    central global object. Inside we will include information
    about an hipotetical user:


                ğŸ–¥ï¸//inside userContext.jsğŸŸ¨
                import { createContext } from "react";

                const UserContext = createContext({
                    loggedInUser: "Default User",
                });

                export default UserContext;


    ğŸ”¹Now let's use display the user's name inside our Header
    componentğŸ§© by using the hookğŸª useContextğŸ“–:

                ğŸ–¥ï¸//inside Header.jsğŸŸ¨
                ...
                import { useState, useContext } from "react";
                import UserContext from "../../utils/UserContext";
                
                Header = ()=> {
                return(
                    ....
                    <li className="px-3">{loggedInUser}</li>
                    ...
                )
                }

    
    ğŸ”¹But how do you do it inside a class-based componentsğŸ§©?
    let's do one inside our About.jsğŸŸ¨ componentğŸ§©, this time
    we will not be able to use a hook. Instead we will use a 
    propety called Consumer


                ğŸ–¥ï¸//inside About.jsğŸŸ¨
                ...
                import UserContext from "../../utils/UserContext"
                ...
                class About extends Component {
                    ...
             
                render() {
                    ...
                    return (
                        <div className="about">
                        <h1>About</h1>
                        ğŸ‘‰<UserContext.Consumer
                        >{(data) => {
                            console.log(data)
                        }}</UserContext.Consumer>
                        
                        </div>)
                        }
                    }



    ğŸ”¹You can also destructure the loggedInUser property from the data like:
                    
                    ğŸ–¥ï¸//inside About.jsğŸŸ¨
                    ğŸ‘‰<UserContext.Consumer
                        >{({loggedInUser}) => {
                            console.log(loggedInUser)
                        }}</UserContext.Consumer>


Let say that we need to retrieve some Login information for the user in order to use it
in all the site, how would we do that?ğŸ¤”


    ğŸ”¹We will need to fetch some data a single time when the user Logins in the app
    so for that we will need useEffectğŸ’¥

                    ğŸ–¥ï¸//inside App.jsğŸŸ¨
                    //this will manage the user data: â¬‡ï¸
                    const [userName, setUserName] = useState()

                    useEffect(() => {
                    //make an Api call and send username and password here
                    const data = {
                        name: "Akshay Saini"
                    };
                    //the data we get we'll save it to userInfoâ¬‡ï¸
                    setUserName(data.name)
                }, []);


    ğŸ”¹But we are still getting the default user information inside
    the app, how can we apply userInfo to show in the UI instead of 
    `default user`??ğŸ¤”
    To pass this new information to our context, we can use the 
    âœ¨Context.Provider ğŸ§§âœ¨ and surround our app with the value
    inside, that would be our userName:

                    ğŸ–¥ï¸//inside App.jsğŸŸ¨
                    ğŸ‘‰import UserContext from "../utils/UserContext.js";
                    
                    const AppLayout = () => {
                    const [userName, setUserName] = useState()

                    useEffect(() => {
                         const data = {
                            name: "Akshay Saini"
                        };
                        setUserName(data.name)
                    }, []);

                    return (
                    ğŸ‘‰<UserContext.Provider value={{
                         loggedInUser: userName }}>
                            <div className="app">
                                <Header />
                                <Outlet />
                            </div>
                        </UserContext.Provider>
                    );
                }

    ğŸ”¹We can also nest context.providersğŸ§§ if we wanted
    to:

                    ğŸ–¥ï¸//inside App.jsğŸŸ¨
                    ...
                    const AppLayout = () => {
                        ...
                        return (
                    //Default User in the global context
                        ğŸ‘‰<UserContext.Provider value={{
                             loggedInUser: userName }}>
                            <div className="app">
                             ğŸ‘‰<UserContext.Provider value={{
                                 loggedInUser: "Elon Musk }}>
                                <Header />
                                </UserContext.Provider>
                            <Outlet />
                        </div>
                        </UserContext.Provider>
                        )
                    }

    ğŸ”¹Now the loggedInUser will be "Akshay Saini" in all the 
    app except inside the Header and outside of the app layout


ğŸ”´-----Updating a contextğŸ“– ------

Let's add a new feature that will update our loggedInUserğŸ‘¤ according
with what we write inside an input box, in order to see how we can 
update a REACTâš›ï¸ contextğŸ“–

    ğŸ”¹First we'll create an input box inside our Body componentğŸ§©

                    ğŸ–¥ï¸//inside Body.jsğŸŸ¨
                    ...
                    const Body = () => {
                        ...
                        return (
                            ...
                    <div>
                    <label>Username: </label>
                    <input type="text" />
                </div>
                        )
                    }


    ğŸ”¹And then we need to give it the hability to change our
    loggedInUserğŸ‘¤by passing the function we created inside
    App.jsğŸŸ¨ as a prop:

                    ğŸ–¥ï¸//inside App.jsğŸŸ¨
                    ...
                    const AppLayout = () => {
                        ...
                        return (
                     <UserContext.Provider value={{
                        ğŸ‘‰loggedInUser: userName, setUserName }}>
                    <div className="app">
                            <Header />
                        <Outlet />
                    </div>
                    </UserContext.Provider>
                        )

                    }

    ğŸ”¹Now we can use it inside our input box, to change our loggedInUserğŸ‘¤
    With an OnChange

                        ğŸ–¥ï¸//inside Body.jsğŸŸ¨
                    ...
                    const Body = () => {
                        ...
                        return (
                            ...
                    <div>
                    <label>Username: </label>
                    <input type="text" 
                    value={loggedInUser}
                    OnChange={(e)=> setUserName(e.target.value)}/>
                </div>
                        )
                    }


REACTâš›ï¸ ContextğŸ“– is a powerful tool to store information,
another way we have to store it is using Redux. which is used more
in large size apps. Red